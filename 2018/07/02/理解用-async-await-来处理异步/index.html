<!DOCTYPE html><html lang="zh-Hant-HK"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta http-equiv="X-UA-Compatible" content="ie=edge"><title>理解用 async/await 来处理异步 | 佛性前端</title><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"><script src="/js/third-party/jquery.min.js">           </script><script src="/js/third-party/velocity.min.js">           </script><script src="/js/third-party/velocity.ui.min.js">           </script><link rel="icon" href="/img/favicon.ico"></head><body><nav id="nav-bar"><nav class="clear-fix" id="nav-container"><div class="pull-left" id="page-home"><a href="/">佛性前端</a></div><i class="fa fa-bars pull-right" id="toggle-nav" aria-hidden="true"></i><ul class="pull-right" id="navs"><li><a class="nav" href="/">Home</a></li><li><a class="nav" href="/about">About</a></li><li><a class="nav" href="/tags">Tags</a></li></ul></nav></nav><header id="header-info"><div id="header-container"><div id="site-info"><div id="terminal-pl"><div id="top-bar"><ul id="control"><li class="btn"></li><li class="btn"></li><li class="btn"></li></ul><div id="file-path"><i class="fa fa-folder folder-ic" aria-hidden="true"></i> 小bbbbbb 10 X 10</div></div><div id="code-pl">Last updated: 2018-07-02<br>小bbbbbb:~ Desktop$ <span class="code-pl-input">node 理解用 async/await 来处理异步.js</span><br><br>> Post.tags <br><a class="tag" href="#ES6"><span>ES6</span></a><a class="tag" href="#异步"><span>异步</span></a><a class="tag" href="#async/await"><span>async/await</span></a><br><br>> Post.next <br><a href="/2018/07/02/JavaScript-概念：BOM-window-ducoment、DOM-document-element-event/"><span class="answer">JavaScript 概念：BOM、DOM</span></a></div></div></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><a class="article-title">理解用 async/await 来处理异步</a><time class="article-date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-07-02</time><p>本文主要介绍async/await，async 是“异步”的简写，而 await 可以认为是 async wait 的简写。所以应该很好理解 async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。<br>[//]: 引用：<a href="https://www.cnblogs.com/SamWeb/p/8417940.html" target="_blank" rel="noopener">https://www.cnblogs.com/SamWeb/p/8417940.html</a></p>
<a id="more"></a>
<h3 id="async的用法"><a href="#async的用法" class="headerlink" title="async的用法"></a>async的用法</h3><p>async 作为一个关键字放到函数前面，用于表示函数是一个异步函数，因为async就是异步的意思， 异步函数也就意味着该函数的执行不会阻塞后面代码的执行。 写一个async 函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">async function func() &#123;</span><br><span class="line">　　return &apos;hello world&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>语法很简单，就是在函数前面加上 async 关键字，来表示它是异步的，那怎么调用呢？async 函数也是函数，平时我们怎么使用函数就怎么使用它，直接加括号调用就可以了，为了表示它没有阻塞它后面代码的执行，我们在async 函数调用之后加一句 console.log;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">async function func() &#123;</span><br><span class="line">    return &apos;hello world&apos;</span><br><span class="line">&#125;</span><br><span class="line">func();     // 直接调用 func() ，控制台没有返回</span><br><span class="line">console.log( &apos;虽然在后面，但是我先执行...&apos; );</span><br></pre></td></tr></table></figure></p>
<p>控制输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 输出</span><br><span class="line">虽然在后面，但是我先执行...</span><br></pre></td></tr></table></figure></p>
<p>async 函数 func 调用了，但是没有任何输出，它不是应该返回 ‘hello world’，先不要着急，看一看 func() 执行返回了什么？ 把上面的 func() 语句改为 console.log(func())；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">async function func() &#123;</span><br><span class="line">    return &apos;hello world&apos;</span><br><span class="line">&#125;</span><br><span class="line">console.log( func() );     //</span><br><span class="line">console.log( &apos;虽然在后面，但是我先执行...&apos; );</span><br></pre></td></tr></table></figure>
<p>控制输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Promise &#123;&lt;resolved&gt;: &quot;hello world&quot;&#125;     // console.log( func() );</span><br><span class="line">虽然在后面，但是我先执行...                 // console.log( &apos;虽然在后面，但是我先执行...&apos; );</span><br></pre></td></tr></table></figure></p>
<p>原来 async 函数返回的是一个 promise 对象，如果要获取到 promise 返回值，我们应该用 then 方法， 继续修改代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async function func() &#123;</span><br><span class="line">    return &apos;hello world&apos;;</span><br><span class="line">&#125;</span><br><span class="line">func().then(result =&gt; &#123;</span><br><span class="line">    console.log(result);                // 后输出</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&apos;虽然在后面，但是我先执行&apos;);    // 先输出</span><br></pre></td></tr></table></figure></p>
<p>控制台输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">虽然在后面，但是我先执行</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure></p>
<p>获取到了”hello world’,  同时 func 的执行也没有阻塞后面代码的执行。</p>
<p>这时，你可能注意到控制台中的 Promise 有一个resolved，这是 async 函数内部的实现原理。如果 async 函数中有返回一个值 ,当调用该函数时，内部会调用 Promise.solve() 方法把它转化成一个 promise 对象作为返回，但如果 func 函数内部抛出错误呢？那么就会调用 Promise.reject() 返回一个 promise 对象， 这时修改一下 func 函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">async function func( flag ) &#123;</span><br><span class="line">    if( flag ) &#123;</span><br><span class="line">        return &apos;hello world&apos;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw &apos;my god, failure&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(func(true))  // 调用 Promise.resolve() 返回 promise 对象。</span><br><span class="line">console.log(func(false)); // 调用 Promise.reject() 返回 promise 对象。</span><br></pre></td></tr></table></figure></p>
<p>控制台输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Promise &#123;&lt;resolved&gt;: &quot;hello world&quot;&#125;</span><br><span class="line">Promise &#123;&lt;rejected&gt;: &quot;my god, failure&quot;&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果函数内部抛出错误， promise 对象有一个catch 方法进行捕获。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func(false).catch(err =&gt; &#123;</span><br><span class="line">    console.log( err );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="await的用法"><a href="#await的用法" class="headerlink" title="await的用法"></a>await的用法</h3><p>await是等待的意思，那么它等待什么呢，它后面跟着什么呢？其实它后面可以放任何表达式，不过我们更多的是放一个返回 promise 对象的表达式。注意 await 关键字只能放到 async 函数里面。</p>
<p>看例子：现在写一个函数，让它返回 promise 对象，该函数的作用是2s 之后让数值乘以2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 2s 之后返回双倍的值</span><br><span class="line">function doubleAfter2seconds(num) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(2 * num)</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125; )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在再写一个 async 函数，从而可以使用 await 关键字， await 后面放置的就是返回 promise 对象的一个表达式，所以它后面可以写上 doubleAfter2seconds 函数的调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">async function testResult() &#123;</span><br><span class="line">    let result = await doubleAfter2seconds(30);</span><br><span class="line">    console.log(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>控制台输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">testResult();</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">2s 之后，输出了 60</span><br></pre></td></tr></table></figure></p>
<p>现在我们看看代码的执行过程，调用 testResult 函数，它里面遇到了await, await 表示等一下，代码就暂停到这里，不再向下执行了，它等什么呢？等后面的promise对象执行完毕，然后拿到 promise resolve 的值并进行返回，返回值拿到之后，它继续向下执行。具体到 我们的代码, 遇到 await 之后，代码就暂停执行了， 等待 doubleAfter2seconds(30) 执行完毕，doubleAfter2seconds(30) 返回的 promise 开始执行，2秒之后，promise resolve 了， 并返回了值为60， 这时 await 才拿到返回值60， 然后赋值给 result， 暂停结束，代码才开始继续执行，执行 console.log语句。</p>
<p>就这一个函数，我们可能看不出async/await 的作用，如果我们要计算3个数的值，然后把得到的值进行输出呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async function testResult() &#123;</span><br><span class="line">    let first = await doubleAfter2seconds(30);</span><br><span class="line">    let second = await doubleAfter2seconds(50);</span><br><span class="line">    let third = await doubleAfter2seconds(30);</span><br><span class="line">    console.log( first + second + third );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6秒后，控制台输出220, 我们可以看到，写异步代码就像写同步代码一样了，再也没有回调地域了。</p>
</article><nav id="pagination"><div class="pagination clear-fix"><div class="page-next pull-right"><a href="/2018/07/02/JavaScript-概念：BOM-window-ducoment、DOM-document-element-event/"><span>JavaScript 概念：BOM、DOM</span><i class="fa fa-chevron-right"></i></a></div></div></nav></div></div><footer><div id="footer-inner"><div class="social-icons"></div><p class="design-info">power by <a href="https://hexo.io" target="_blank">Hexo</a> | theme <a href="https://github.com/lazysheep666/terminal_theme" target="_blank">Teminal</a></p><p class="copyright">Copyright © 小bbbbbb Blog 2019</p></div></footer><script src="/js/nav.js"></script><script src="/js/scroll.js"></script><script src="/js/index.js"></script></body></html>