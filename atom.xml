<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>佛性前端</title>
  
  <subtitle>你们最喜欢的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-25T14:44:59.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>小bbbbbb</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS数据结构：字典</title>
    <link href="http://yoursite.com/2019/03/25/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%AD%97%E5%85%B8/"/>
    <id>http://yoursite.com/2019/03/25/JS数据结构：字典/</id>
    <published>2019-03-25T14:39:59.000Z</published>
    <updated>2019-03-25T14:44:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>在字典中，存储的是[键，值] 对，其中键名是用来查询特定元素的。</p><a id="more"></a><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>字典(Dictionary)是一种以 键-值对 形式存储数据的数据结构 ，就如同我们平时查看通讯录一样，要找一个电话，首先先找到该号码的机主名字，名字找到了，紧接着电话号码也就有了。这里的键就是你用来查找的东西，本例中指代的就是名字，值就是查找得到的结果，也就是对应的电话号码。<br>其实，JavaScript 中的 Object 类就是以字典的形式设计的，下面我们将会借助 Object 类的特性，自主实现一个 Dictionary 类，让这种字典类型的对象使用起来更加方便。</p><h3 id="字典的创建"><a href="#字典的创建" class="headerlink" title="字典的创建"></a>字典的创建</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dictionary</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.items = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向字典中添加新元素</span></span><br><span class="line">    set( key, value ) &#123;</span><br><span class="line">        <span class="keyword">this</span>.items[key] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果某个键值存在于这个字典中，则返回true，反之则返回false</span></span><br><span class="line">    has( key ) &#123;</span><br><span class="line">        <span class="keyword">return</span> key <span class="keyword">in</span> <span class="keyword">this</span>.items;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过键值查找特定的数值并返回</span></span><br><span class="line">    get( key ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.has(key) ? <span class="keyword">this</span>.items[key] : <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.items).length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将这个字典中的所有元素全部删除</span></span><br><span class="line">    clear() &#123;</span><br><span class="line">        <span class="keyword">this</span>.items = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过使用键值来从字典中移除键值对应的数据值</span></span><br><span class="line">    <span class="keyword">delete</span>( key ) &#123;</span><br><span class="line">        <span class="keyword">if</span>( <span class="keyword">this</span>.has(key) ) &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>.items[key];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// keys方法返回在Dictionary类中所有用于标识值的键名</span></span><br><span class="line">    keys() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.keys( <span class="keyword">this</span>.items );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将字典所包含的所有数值以数组形式返回</span></span><br><span class="line">    values() &#123;</span><br><span class="line">        <span class="keyword">let</span> values = [];</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">let</span> i = <span class="number">0</span>, keys = <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.items); i &lt; keys.length; i++ ) &#123;</span><br><span class="line">            values.push( <span class="keyword">this</span>.items[keys[i]] );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> values;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getItems() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用字典"><a href="#使用字典" class="headerlink" title="使用字典"></a>使用字典</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>字典<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>在字典中，存储的是[键，值] 对，其中键名是用来查询特定元素的。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"Dictionary.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> dictionary = <span class="keyword">new</span> Dictionary();</span></span><br><span class="line"><span class="javascript">            dictionary.set( <span class="string">'Gandalf'</span>, <span class="string">'gandalf@email.com'</span> );</span></span><br><span class="line"><span class="javascript">            dictionary.set( <span class="string">'John'</span>, <span class="string">'johnsnow@email.com'</span> );</span></span><br><span class="line"><span class="javascript">            dictionary.set( <span class="string">'Tyrion'</span>, <span class="string">'tyrion@email.com'</span> );</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log( dictionary.has(<span class="string">'Gandalf'</span>) );   <span class="comment">// true</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log( dictionary.size() );</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log( dictionary.keys() );</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log( dictionary.values() );</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log( dictionary.get(<span class="string">'Tyrion'</span>) );</span></span><br><span class="line"><span class="undefined">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在字典中，存储的是[键，值] 对，其中键名是用来查询特定元素的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JS数据结构" scheme="http://yoursite.com/tags/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="字典" scheme="http://yoursite.com/tags/%E5%AD%97%E5%85%B8/"/>
    
  </entry>
  
  <entry>
    <title>JS数据结构：队列</title>
    <link href="http://yoursite.com/2019/03/25/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2019/03/25/JS数据结构：队列/</id>
    <published>2019-03-25T14:31:07.000Z</published>
    <updated>2019-03-25T14:37:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们已经接触了栈，接下来要说的队列和栈十分相似，他们都是线性表，元素都是有序的 。队列和栈不同的是，队列遵循的是FIFO，也就是先进先出的原则。队列从尾部添加新元素，从顶部移除元素，最新添加的元素必须排列在队列的末尾。</p><a id="more"></a><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>在现实生活中，最常见的队列就是排队，比如买票，先进入队列的先接受服务，后进入队列的必须排在队列末尾。</p><h3 id="队列的创建"><a href="#队列的创建" class="headerlink" title="队列的创建"></a>队列的创建</h3><p>首先我们声明一个类：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//这里是队列的属性和方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后我们同样创建一个保存元素的数组：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> items = [];</span><br></pre></td></tr></table></figure></p><p>接下来声明一些队列可用的方法：</p><ul><li>enqueue(element):向队列尾部添加一个（或是多个）元素。</li><li>dequeue():移除队列的第一个元素，并返回被移除的元素。</li><li>front():返回队列的第一个元素——最先被添加的也是最先被移除的元素。队列不做任何变动。</li><li>isEmpty():检查队列内是否有元素，如果有返回true，没有返回false。</li><li>size():返回队列的长度。</li><li>print():打印队列的元素。</li></ul><h3 id="队列的完整代码"><a href="#队列的完整代码" class="headerlink" title="队列的完整代码"></a>队列的完整代码</h3><p>我们通过javascript提供的API，实现队列如下(ES5版本)：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> items = [];</span><br><span class="line">    <span class="keyword">this</span>.enqueue = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line">        items.push(element);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.dequeue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items.shift();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.front = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items[<span class="number">0</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items.length == <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        items = [];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items.length;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(items.toString());</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ES6 版本：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.items = [];    <span class="comment">// 存储数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    enqueue( item ) &#123;       <span class="comment">// 向队尾添加一个元素</span></span><br><span class="line">        <span class="keyword">this</span>.items.push( item );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dequeue() &#123;             <span class="comment">// 删除队首的一个元素</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.shift();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    head() &#123;                <span class="comment">// 返回队首的一个元素</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tail() &#123;                <span class="comment">// 返回队尾的一个元素</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items[<span class="keyword">this</span>.items.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size() &#123;                <span class="comment">// 返回队列的长度</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    isEmpty() &#123;             <span class="comment">// 返回队列是否为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.length === <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    clear() &#123;               <span class="comment">// 清空队列</span></span><br><span class="line">        <span class="keyword">this</span>.items = [];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="使用队列"><a href="#使用队列" class="headerlink" title="使用队列"></a>使用队列</h3><p>创建完了队列，也给他了方法，然后我们来实例化一个对象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> queue=<span class="keyword">new</span> Queue();</span><br><span class="line"><span class="built_in">console</span>.log(queue.isEmpty());</span><br><span class="line"><span class="comment">//true</span></span><br><span class="line">queue.enqueue(<span class="number">1</span>);</span><br><span class="line">queue.enqueue(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//添加元素</span></span><br><span class="line"><span class="built_in">console</span>.log(queue.front());</span><br><span class="line"><span class="comment">//返回队列的第一个元素1</span></span><br><span class="line"><span class="built_in">console</span>.log(queue.size());</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//输出元素个数</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们已经接触了栈，接下来要说的队列和栈十分相似，他们都是线性表，元素都是有序的 。队列和栈不同的是，队列遵循的是FIFO，也就是先进先出的原则。队列从尾部添加新元素，从顶部移除元素，最新添加的元素必须排列在队列的末尾。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JS数据结构" scheme="http://yoursite.com/tags/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="队列" scheme="http://yoursite.com/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>JS数据结构：栈</title>
    <link href="http://yoursite.com/2019/03/25/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%88/"/>
    <id>http://yoursite.com/2019/03/25/JS数据结构：栈/</id>
    <published>2019-03-25T14:25:59.000Z</published>
    <updated>2019-03-25T14:38:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>栈是一种遵从后进先出(LIFO)原则的有序集合。新添加的或是待删除的元素都保存在栈的末尾。我们称作栈顶，而另一端我们称作栈底。</p><a id="more"></a><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>在现实生活中就有很多栈的例子，比如竖着放的书本，这一摞书如果要取肯定是先去最上面的那一本，但它是最后一个放上去的，也就是栈顶的元素都是待添加或是待删除的。这就是后进先出的实际例子。</p><h3 id="栈的创建"><a href="#栈的创建" class="headerlink" title="栈的创建"></a>栈的创建</h3><p>首先我们先创建一个类：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//各种属性和方法的声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后我们需要一种数据结构来保存栈里面的数据：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> items = [];</span><br></pre></td></tr></table></figure></p><p>接下来，我们需要给栈声明一些方法：</p><ul><li>push(element):添加一个或是几个新元素到栈顶。</li><li>pop():移除栈顶的元素，同时返回被移除元素。</li><li>peek():返回栈顶的元素，但并不对栈顶的元素做出任何的修改。</li><li>isEmpty():检查栈内是否有元素，如果有返回true，没有返回false。</li><li>clear():清除栈里的元素。</li><li>size():返回栈的元素个数。</li><li>print():打印栈里的元素。</li></ul><h3 id="栈的完整代码"><a href="#栈的完整代码" class="headerlink" title="栈的完整代码"></a>栈的完整代码</h3><p>我们通过javascript提供的API，实现栈如下(ES5版本)：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> items = [];</span><br><span class="line">    <span class="keyword">this</span>.push = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line">        items.push(element);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.pop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items.pop();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.peek = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items[items.length<span class="number">-1</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items.length == <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items.length;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        items = [];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(items.toString());</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items.toString();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ES6 版本：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.items = [];    <span class="comment">// 使用数组存储数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    push( item ) &#123;</span><br><span class="line">        <span class="keyword">this</span>.items.push( item );    <span class="comment">// 往栈里压入一个元素</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pop() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.pop();    <span class="comment">// 把栈顶的元素移除</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    top() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items[ <span class="keyword">this</span>.items.length - <span class="number">1</span> ]; <span class="comment">// 返回栈顶的元素</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    isEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.length === <span class="number">0</span>;     <span class="comment">// 返回栈是否为空</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    clear() &#123;</span><br><span class="line">        <span class="keyword">this</span>.items = [];    <span class="comment">// 清空栈</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="使用栈"><a href="#使用栈" class="headerlink" title="使用栈"></a>使用栈</h3><p>创建完了栈，也给他了方法，然后我们来实例化一个对象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stack=<span class="keyword">new</span> Stack();</span><br><span class="line"><span class="built_in">console</span>.log(stack.isEmpty());</span><br><span class="line"><span class="comment">//true</span></span><br><span class="line">stack.push(<span class="number">1</span>);</span><br><span class="line">stack.push(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//添加元素</span></span><br><span class="line"><span class="built_in">console</span>.log(stack.peek());</span><br><span class="line"><span class="comment">//输出栈顶元素3</span></span><br><span class="line"><span class="built_in">console</span>.log(stack.size());</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//输出元素个数</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;栈是一种遵从后进先出(LIFO)原则的有序集合。新添加的或是待删除的元素都保存在栈的末尾。我们称作栈顶，而另一端我们称作栈底。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JS数据结构" scheme="http://yoursite.com/tags/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="栈" scheme="http://yoursite.com/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>gulp实现自动watch(gulp-watch)和自动刷新页面(browser-sync)</title>
    <link href="http://yoursite.com/2019/03/25/gulp%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E7%9B%91%E5%90%ACgulp-watch%E5%92%8C%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2browser-sync/"/>
    <id>http://yoursite.com/2019/03/25/gulp实现自动监听gulp-watch和自动刷新页面browser-sync/</id>
    <published>2019-03-25T03:43:52.000Z</published>
    <updated>2019-03-25T03:59:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要学习gulp实现自动watch(gulp-watch)和自动刷新页面(browser-sync)，自己做个总结，以防忘记。</p><a id="more"></a><h3 id="1、直接看-gulpfile-js-配置文件"><a href="#1、直接看-gulpfile-js-配置文件" class="headerlink" title="1、直接看 gulpfile.js 配置文件"></a>1、直接看 gulpfile.js 配置文件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">var</span> watch = <span class="built_in">require</span>(<span class="string">'gulp-watch'</span>);</span><br><span class="line"><span class="keyword">var</span> sass = <span class="built_in">require</span>(<span class="string">'gulp-sass'</span>);</span><br><span class="line"><span class="keyword">var</span> clean = <span class="built_in">require</span>(<span class="string">'gulp-clean'</span>);          <span class="comment">// 清空文件夹</span></span><br><span class="line"><span class="keyword">var</span> browserSync = <span class="built_in">require</span>(<span class="string">'browser-sync'</span>).create();    <span class="comment">// 用来打开一个浏览器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> html_path = <span class="string">'src/**/*.html'</span>;</span><br><span class="line"><span class="keyword">var</span> css_libs_path = <span class="string">'src/css/**/*.css'</span>;</span><br><span class="line"><span class="keyword">var</span> sass_libs_path = <span class="string">'src/css/**/*.scss'</span>;</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'watch'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    w(<span class="string">'./src/**/*.html'</span>, <span class="string">'html'</span>);</span><br><span class="line">    w(css_libs_path, <span class="string">'css_libs'</span>);</span><br><span class="line">    w(sass_libs_path, <span class="string">'sass_libs'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">w</span>(<span class="params">path, task</span>)</span>&#123;</span><br><span class="line">        watch(path, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            gulp.start(task);</span><br><span class="line">            browserSync.reload();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空dist文件夹</span></span><br><span class="line">gulp.task(<span class="string">'clean'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> gulp.src([<span class="string">'dist/*'</span>])</span><br><span class="line">.pipe(clean());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// html模板处理</span></span><br><span class="line">gulp.task(<span class="string">'html'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(html_path)</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'dist'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打包css</span></span><br><span class="line">gulp.task(<span class="string">'css_libs'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(css_libs_path)</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'dist/css'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打包sass</span></span><br><span class="line">gulp.task(<span class="string">'sass_libs'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(sass_libs_path)</span><br><span class="line">        .pipe(sass().on(<span class="string">'error'</span>, sass.logError))</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'dist/css'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启本地服务，并打开浏览器</span></span><br><span class="line">gulp.task(<span class="string">'browser'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">browserSync.init(&#123;</span><br><span class="line">        server: <span class="string">'dist'</span>    <span class="comment">// 访问目录，自动指向该目录下的 index.html 文件</span></span><br><span class="line">        <span class="comment">// proxy: "你的域名或IP"    // 设置代理</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加入'watch'任务</span></span><br><span class="line">gulp.task(<span class="string">'default'</span>, [<span class="string">'clean'</span>], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    gulp.start([<span class="string">'html'</span>, <span class="string">'css_libs'</span>, <span class="string">'sass_libs'</span>, <span class="string">'browser'</span>, <span class="string">'watch'</span>])</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="2、目录结构"><a href="#2、目录结构" class="headerlink" title="2、目录结构"></a>2、目录结构</h3><p><img src="//upload-images.jianshu.io/upload_images/1726248-490cb4b246e6737c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="目录结构"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要学习gulp实现自动watch(gulp-watch)和自动刷新页面(browser-sync)，自己做个总结，以防忘记。&lt;/p&gt;
    
    </summary>
    
    
      <category term="gulp" scheme="http://yoursite.com/tags/gulp/"/>
    
      <category term="gulp-watch" scheme="http://yoursite.com/tags/gulp-watch/"/>
    
      <category term="browser-sync" scheme="http://yoursite.com/tags/browser-sync/"/>
    
  </entry>
  
  <entry>
    <title>理解用 async/await 来处理异步</title>
    <link href="http://yoursite.com/2018/07/02/%E7%90%86%E8%A7%A3%E7%94%A8-async-await-%E6%9D%A5%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5/"/>
    <id>http://yoursite.com/2018/07/02/理解用-async-await-来处理异步/</id>
    <published>2018-07-02T08:00:40.000Z</published>
    <updated>2018-07-03T08:26:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍async/await，async 是“异步”的简写，而 await 可以认为是 async wait 的简写。所以应该很好理解 async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。<br>[//]: 引用：<a href="https://www.cnblogs.com/SamWeb/p/8417940.html" target="_blank" rel="noopener">https://www.cnblogs.com/SamWeb/p/8417940.html</a></p><a id="more"></a><h3 id="async的用法"><a href="#async的用法" class="headerlink" title="async的用法"></a>async的用法</h3><p>async 作为一个关键字放到函数前面，用于表示函数是一个异步函数，因为async就是异步的意思， 异步函数也就意味着该函数的执行不会阻塞后面代码的执行。 写一个async 函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">async function func() &#123;</span><br><span class="line">　　return &apos;hello world&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语法很简单，就是在函数前面加上 async 关键字，来表示它是异步的，那怎么调用呢？async 函数也是函数，平时我们怎么使用函数就怎么使用它，直接加括号调用就可以了，为了表示它没有阻塞它后面代码的执行，我们在async 函数调用之后加一句 console.log;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">async function func() &#123;</span><br><span class="line">    return &apos;hello world&apos;</span><br><span class="line">&#125;</span><br><span class="line">func();     // 直接调用 func() ，控制台没有返回</span><br><span class="line">console.log( &apos;虽然在后面，但是我先执行...&apos; );</span><br></pre></td></tr></table></figure></p><p>控制输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 输出</span><br><span class="line">虽然在后面，但是我先执行...</span><br></pre></td></tr></table></figure></p><p>async 函数 func 调用了，但是没有任何输出，它不是应该返回 ‘hello world’，先不要着急，看一看 func() 执行返回了什么？ 把上面的 func() 语句改为 console.log(func())；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">async function func() &#123;</span><br><span class="line">    return &apos;hello world&apos;</span><br><span class="line">&#125;</span><br><span class="line">console.log( func() );     //</span><br><span class="line">console.log( &apos;虽然在后面，但是我先执行...&apos; );</span><br></pre></td></tr></table></figure><p>控制输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Promise &#123;&lt;resolved&gt;: &quot;hello world&quot;&#125;     // console.log( func() );</span><br><span class="line">虽然在后面，但是我先执行...                 // console.log( &apos;虽然在后面，但是我先执行...&apos; );</span><br></pre></td></tr></table></figure></p><p>原来 async 函数返回的是一个 promise 对象，如果要获取到 promise 返回值，我们应该用 then 方法， 继续修改代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async function func() &#123;</span><br><span class="line">    return &apos;hello world&apos;;</span><br><span class="line">&#125;</span><br><span class="line">func().then(result =&gt; &#123;</span><br><span class="line">    console.log(result);                // 后输出</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&apos;虽然在后面，但是我先执行&apos;);    // 先输出</span><br></pre></td></tr></table></figure></p><p>控制台输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">虽然在后面，但是我先执行</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure></p><p>获取到了”hello world’,  同时 func 的执行也没有阻塞后面代码的执行。</p><p>这时，你可能注意到控制台中的 Promise 有一个resolved，这是 async 函数内部的实现原理。如果 async 函数中有返回一个值 ,当调用该函数时，内部会调用 Promise.solve() 方法把它转化成一个 promise 对象作为返回，但如果 func 函数内部抛出错误呢？那么就会调用 Promise.reject() 返回一个 promise 对象， 这时修改一下 func 函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">async function func( flag ) &#123;</span><br><span class="line">    if( flag ) &#123;</span><br><span class="line">        return &apos;hello world&apos;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw &apos;my god, failure&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(func(true))  // 调用 Promise.resolve() 返回 promise 对象。</span><br><span class="line">console.log(func(false)); // 调用 Promise.reject() 返回 promise 对象。</span><br></pre></td></tr></table></figure></p><p>控制台输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Promise &#123;&lt;resolved&gt;: &quot;hello world&quot;&#125;</span><br><span class="line">Promise &#123;&lt;rejected&gt;: &quot;my god, failure&quot;&#125;</span><br></pre></td></tr></table></figure></p><p>如果函数内部抛出错误， promise 对象有一个catch 方法进行捕获。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func(false).catch(err =&gt; &#123;</span><br><span class="line">    console.log( err );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="await的用法"><a href="#await的用法" class="headerlink" title="await的用法"></a>await的用法</h3><p>await是等待的意思，那么它等待什么呢，它后面跟着什么呢？其实它后面可以放任何表达式，不过我们更多的是放一个返回 promise 对象的表达式。注意 await 关键字只能放到 async 函数里面。</p><p>看例子：现在写一个函数，让它返回 promise 对象，该函数的作用是2s 之后让数值乘以2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 2s 之后返回双倍的值</span><br><span class="line">function doubleAfter2seconds(num) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(2 * num)</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125; )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在再写一个 async 函数，从而可以使用 await 关键字， await 后面放置的就是返回 promise 对象的一个表达式，所以它后面可以写上 doubleAfter2seconds 函数的调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">async function testResult() &#123;</span><br><span class="line">    let result = await doubleAfter2seconds(30);</span><br><span class="line">    console.log(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>控制台输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">testResult();</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">2s 之后，输出了 60</span><br></pre></td></tr></table></figure></p><p>现在我们看看代码的执行过程，调用 testResult 函数，它里面遇到了await, await 表示等一下，代码就暂停到这里，不再向下执行了，它等什么呢？等后面的promise对象执行完毕，然后拿到 promise resolve 的值并进行返回，返回值拿到之后，它继续向下执行。具体到 我们的代码, 遇到 await 之后，代码就暂停执行了， 等待 doubleAfter2seconds(30) 执行完毕，doubleAfter2seconds(30) 返回的 promise 开始执行，2秒之后，promise resolve 了， 并返回了值为60， 这时 await 才拿到返回值60， 然后赋值给 result， 暂停结束，代码才开始继续执行，执行 console.log语句。</p><p>就这一个函数，我们可能看不出async/await 的作用，如果我们要计算3个数的值，然后把得到的值进行输出呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async function testResult() &#123;</span><br><span class="line">    let first = await doubleAfter2seconds(30);</span><br><span class="line">    let second = await doubleAfter2seconds(50);</span><br><span class="line">    let third = await doubleAfter2seconds(30);</span><br><span class="line">    console.log( first + second + third );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6秒后，控制台输出220, 我们可以看到，写异步代码就像写同步代码一样了，再也没有回调地域了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍async/await，async 是“异步”的简写，而 await 可以认为是 async wait 的简写。所以应该很好理解 async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。&lt;br&gt;[//]: 引用：&lt;a href=&quot;https://www.cnblogs.com/SamWeb/p/8417940.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/SamWeb/p/8417940.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
      <category term="异步" scheme="http://yoursite.com/tags/%E5%BC%82%E6%AD%A5/"/>
    
      <category term="async/await" scheme="http://yoursite.com/tags/async-await/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 概念：BOM、DOM</title>
    <link href="http://yoursite.com/2018/07/02/JavaScript-%E6%A6%82%E5%BF%B5%EF%BC%9ABOM-window-ducoment%E3%80%81DOM-document-element-event/"/>
    <id>http://yoursite.com/2018/07/02/JavaScript-概念：BOM-window-ducoment、DOM-document-element-event/</id>
    <published>2018-07-02T02:27:12.000Z</published>
    <updated>2018-07-02T03:41:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍BOM与DOM。</p><a id="more"></a><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>JavaScript = EMCAScript + BOM + DOM</p><p>BOM 定义了JavaScript可以进行操作的浏览器的各个功能部件的接口；<br>DOM 是一个使程序和脚本有能力动态地访问和更新文档的内容、结构以及样式的平台和语言中立的接口。</p><ul><li>DOM是W3C的标准（所有浏览器公共遵守的标准）</li><li>BOM是各个浏览器厂商根据DOM在各自浏览器上的实现</li></ul><p>注：<strong>window VS. document，BOM VS. DOM</strong></p><p>window是BOM对象，而非JavaScript对象，Window 对象表示浏览器中打开的窗口，不过恰好为EMCAScript中所定义的Global对象。BOM的核心是window，而window对象又具有双重角色，它既是通过js访问浏览器窗口的一个接口，又是一个global全局对象。<br>由于window包含了document属性，因此JavaScript可以直接通过使用window的document对象来访问、检索、修改文档内容与结构。因为document对象又是DOM的根节点，所以可以理解为BOM包含了DOM。即浏览器提供出来给予访问的是BOM对象，而BOM对象再访问到DOM对象，从而js可以操作浏览器以及浏览器读取到的文档。</p><p>通俗来讲：<br>DOM 就是针对 HTML 和 XML 提供的一个API，就是说为了能以编程的方法操作这个 HTML 的内容（比如添加某些元素、修改元素的内容、删除某些元素），我们把这个 HTML 看做一个对象树（DOM树），它本身和里面的所有东西比如 <code>&lt;div&gt;&lt;/div&gt;</code> 这些标签都看做一个对象，每个对象都叫做一个节点（node），节点可以理解为 DOM 中所有 Object 的父类。</p><p>DOM 是为了操作文档出现的 API，document 是其的一个对象；<br>BOM 是为了操作浏览器出现的 API，window 是其的一个对象。</p><p>图示化说明（版权非我）</p><p><img src="//yu067.cn/images/BOM-DOM.jpg" alt="BOM-DOM"></p><p>归DOM管的：<br>E区（就是你说的document。由web开发人员呕心沥血写出来的一个文件夹，里面有index.html，CSS和JS什么鬼的，部署在服务器上，我们可以通过浏览器的地址栏输入URL然后回车将这个document加载到本地，浏览，右键查看源代码等）</p><p>归BOM管的：<br>A区（浏览器的标签页，地址栏，搜索栏，书签栏，窗口放大还原关闭按钮，菜单栏等）<br>B区（浏览器的右键菜单）<br>C区（document加载时的状态栏，显示http状态码等）<br>D区（滚动条scroll bar）</p><h3 id="BOM的组成"><a href="#BOM的组成" class="headerlink" title="BOM的组成"></a>BOM的组成</h3><p>BOM（browser object model,API）是Window对象、Document对象、History对象、Location对象、Navigator对象、Screen对象等合起来组成的模型，至今没有各个浏览器统一的公开标准，但是一般各个浏览器都支持。</p><p><img src="//yu067.cn/images/BOM.jpeg" alt="BOM"></p><h3 id="DOM的组成"><a href="#DOM的组成" class="headerlink" title="DOM的组成"></a>DOM的组成</h3><p><img src="//yu067.cn/images/DOM.png" alt="DOM"></p><p>一个网页是由html来搭建结构的，通过css来定义网页的样式，而JavaScript赋予了页面的行为，通过它我们可以与页面进行交互，实现页面的动画效果等等。那javascript究竟通过什么来实现的呢？通过ECMAScript这个标准，我们可以编写程序让浏览器来解析，利用ECMAScript，我们可以通过BOM对象（即browser object model）来操作浏览器窗口、浏览器导航对象(navigator)、屏幕分辨率(screen)、浏览器历史(history)、cookie等等。但这个通过BOM来实现的交互远远不够。要实现页面的动态交互和效果，操作html才是核心。那如何操作html呢？对，就是DOM，简单的说，DOM给我们提供了用程序来动态控制html的接口，也就是早期的DHTMl的概念。因此，DOM处在javascript赋予html具备动态交互和效果的能力的核心地位上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍BOM与DOM。&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript概念" scheme="http://yoursite.com/tags/javascript%E6%A6%82%E5%BF%B5/"/>
    
      <category term="BOM理解" scheme="http://yoursite.com/tags/BOM%E7%90%86%E8%A7%A3/"/>
    
      <category term="DOM理解" scheme="http://yoursite.com/tags/DOM%E7%90%86%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>手机开发问题总结</title>
    <link href="http://yoursite.com/2018/06/17/%E6%89%8B%E6%9C%BA%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/06/17/手机开发问题总结/</id>
    <published>2018-06-17T12:55:31.000Z</published>
    <updated>2018-06-25T02:11:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要汇总手机开发中遇到的问题，并且分析如何解决问题，做好总结。</p><a id="more"></a><h3 id="1、当微信浏览器首次打开页面的时候，如何隐藏底部返回导航条（比如：从公众号跳到页面的时候，底部会带有返回导航条，如果想隐藏请看下面代码）"><a href="#1、当微信浏览器首次打开页面的时候，如何隐藏底部返回导航条（比如：从公众号跳到页面的时候，底部会带有返回导航条，如果想隐藏请看下面代码）" class="headerlink" title="1、当微信浏览器首次打开页面的时候，如何隐藏底部返回导航条（比如：从公众号跳到页面的时候，底部会带有返回导航条，如果想隐藏请看下面代码）"></a>1、当微信浏览器首次打开页面的时候，如何隐藏底部返回导航条（比如：从公众号跳到页面的时候，底部会带有返回导航条，如果想隐藏请看下面代码）</h3><p>只需要在页面初始化的时候，执行以下代码即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 隐藏底部返回导航条</span><br><span class="line">if( history.length &gt; 1 ) &#123;</span><br><span class="line">    var state = &#123;</span><br><span class="line">        title: &quot;title&quot;,</span><br><span class="line">        url: &quot;#&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">    window.history.pushState( state, &quot;title&quot;, &quot;#&quot; );</span><br><span class="line">    window.addEventListener( &quot;popstate&quot;, function( e ) &#123;</span><br><span class="line">        WeixinJSBridge.call( &apos;closeWindow&apos; );</span><br><span class="line">    &#125;, false );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2、当页面有元素固定在页面的底部时，滚动页面，会被浏览器覆盖到页面底部（ios系统）"><a href="#2、当页面有元素固定在页面的底部时，滚动页面，会被浏览器覆盖到页面底部（ios系统）" class="headerlink" title="2、当页面有元素固定在页面的底部时，滚动页面，会被浏览器覆盖到页面底部（ios系统）"></a>2、当页面有元素固定在页面的底部时，滚动页面，会被浏览器覆盖到页面底部（ios系统）</h3><p>在苹果系统中，页面中添加了以下css代码，滚动页面的时候，如果底部有固定元素，则浏览器可能会覆盖到固定元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">html, body &#123;</span><br><span class="line">    height: auto;</span><br><span class="line">    background-color: #fff;</span><br><span class="line">    overflow-y: auto;</span><br><span class="line">    overflow-x: hidden;</span><br><span class="line">    // -webkit-overflow-scrolling: touch;   // 此代码可能会影响元素被覆盖</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3、微信浏览器打开页面，向下滚动页面的时候，顶部导航缩放，底部导航影藏；向上滚动则变为原始状态"><a href="#3、微信浏览器打开页面，向下滚动页面的时候，顶部导航缩放，底部导航影藏；向上滚动则变为原始状态" class="headerlink" title="3、微信浏览器打开页面，向下滚动页面的时候，顶部导航缩放，底部导航影藏；向上滚动则变为原始状态"></a>3、微信浏览器打开页面，向下滚动页面的时候，顶部导航缩放，底部导航影藏；向上滚动则变为原始状态</h3><p>具体实现是不要将<code>html，body</code>的高度设置为100%，如果设置了，在<code>ios</code>系统滚动页面的时候，会导致不流畅。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// html, body 高度不要设置为 100%</span><br><span class="line">html, body &#123;</span><br><span class="line">    height: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要汇总手机开发中遇到的问题，并且分析如何解决问题，做好总结。&lt;/p&gt;
    
    </summary>
    
    
      <category term="手机开发问题" scheme="http://yoursite.com/tags/%E6%89%8B%E6%9C%BA%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>js手机端滚动到底部问题-scroll绑定在body</title>
    <link href="http://yoursite.com/2018/06/16/js%E6%89%8B%E6%9C%BA%E7%AB%AF%E6%BB%9A%E5%8A%A8%E5%88%B0%E5%BA%95%E9%83%A8%E9%97%AE%E9%A2%98-scroll%E7%BB%91%E5%AE%9A%E5%9C%A8body/"/>
    <id>http://yoursite.com/2018/06/16/js手机端滚动到底部问题-scroll绑定在body/</id>
    <published>2018-06-16T06:36:07.000Z</published>
    <updated>2018-06-16T06:48:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍了手机端基于javascript实现浏览器滚动条快到底部时自动加载数据，绑定在 body 无法触发 onscroll 和 scroll的问题。</p><a id="more"></a><h3 id="js-代码"><a href="#js-代码" class="headerlink" title="js 代码"></a>js 代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$(function()&#123;</span><br><span class="line">    var totalHeight = 0; //定义一个总高度变量</span><br><span class="line">    $(&quot;body&quot;).scroll(function()&#123;</span><br><span class="line">        console.log( &quot;滚动条到顶部的垂直高度：&quot; +  $(this).scrollTop()  );</span><br><span class="line">        console.log( &quot;页面的文档高度：&quot; +  $(document).height()  );</span><br><span class="line">        console.log( &quot;浏览器的高度：&quot; +  $(this).height()  );</span><br><span class="line"></span><br><span class="line">        totalHeight =  parseFloat( $(this).height() ) +  parseFloat( $(this).scrollTop() ); //浏览器的高度加上滚动条的高度</span><br><span class="line">        if( $(document).height() &lt;= totalHeight ) &#123; //当文档的高度小于或者等于总的高度时，开始动态加载数据</span><br><span class="line">            $( &quot;#container&quot; ).append( &quot;&lt;p&gt;我是新加载出来的数据&lt;/p&gt;&quot; ); //加载数据</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="html-代码"><a href="#html-代码" class="headerlink" title="html 代码"></a>html 代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;content&quot;&gt;</span><br><span class="line">        &lt;p&gt;佛系前端&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;佛系前端&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;佛系前端&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;佛系前端&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;佛系前端&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;佛系前端&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;佛系前端&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;佛系前端&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;佛系前端&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;佛系前端&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;佛系前端&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;佛系前端&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;佛系前端&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;佛系前端&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;佛系前端&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;佛系前端&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;佛系前端&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;佛系前端&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;佛系前端&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;佛系前端&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;佛系前端&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div id=&quot;container&quot;&gt;&lt;/div&gt; //加载数据的位置</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h3 id="css-代码"><a href="#css-代码" class="headerlink" title="css 代码"></a>css 代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">html,body&#123;</span><br><span class="line">    font-size: 37.5px;</span><br><span class="line">    overflow-y: auto;</span><br><span class="line">    overflow-x: hidden;</span><br><span class="line">    width:100%;</span><br><span class="line">    height:100%;     // 在手机开发中，当 html,body 没设置 &#123;width:100%;height:100%;&#125;的时候，绑定在 body 无法触发 onscroll 和 scroll，即 jq 和 js 都不会触发scroll事件！</span><br><span class="line">     /* -webkit-overflow-scrolling: touch; */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：在手机开发中，当 html,body 没设置 {width:100%;height:100%;} 的时候，绑定在 body 无法触发 onscroll 和 scroll，即 jq 和 js 都不会触发scroll事件！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍了手机端基于javascript实现浏览器滚动条快到底部时自动加载数据，绑定在 body 无法触发 onscroll 和 scroll的问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="手机开发" scheme="http://yoursite.com/tags/%E6%89%8B%E6%9C%BA%E5%BC%80%E5%8F%91/"/>
    
      <category term="js滚动加载问题" scheme="http://yoursite.com/tags/js%E6%BB%9A%E5%8A%A8%E5%8A%A0%E8%BD%BD%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>js手机端滚动到底部问题-scroll绑定在window</title>
    <link href="http://yoursite.com/2018/06/16/js%E6%89%8B%E6%9C%BA%E7%AB%AF%E6%BB%9A%E5%8A%A8%E5%88%B0%E5%BA%95%E9%83%A8%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/06/16/js手机端滚动到底部问题/</id>
    <published>2018-06-16T06:30:14.000Z</published>
    <updated>2018-06-16T06:48:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍了手机端基于javascript实现浏览器滚动条快到底部时自动加载数据，绑定在 window 无法触发 onscroll 和 scroll的问题。</p><a id="more"></a><h3 id="js-代码"><a href="#js-代码" class="headerlink" title="js 代码"></a>js 代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$(function()&#123;</span><br><span class="line">    var totalHeight = 0; //定义一个总高度变量</span><br><span class="line">    function ata()&#123; //loa动态加载数据</span><br><span class="line">        totalHeight =  parseFloat( $(window).height() ) +  parseFloat( $(window).scrollTop() ); //浏览器的高度加上滚动条的高度</span><br><span class="line">        if( $(document).height() &lt;= totalHeight ) &#123; //当文档的高度小于或者等于总的高度时，开始动态加载数据</span><br><span class="line">            $( &quot;#container&quot; ).append( &quot;&lt;p&gt;我是新加载出来的数据&lt;/p&gt;&quot; ); //加载数据</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    $(window).scroll(function()&#123;</span><br><span class="line">        console.log( &quot;滚动条到顶部的垂直高度：&quot; +  $(window).scrollTop()  );</span><br><span class="line">        console.log( &quot;页面的文档高度：&quot; +  $(document).height()  );</span><br><span class="line">        console.log( &quot;浏览器的高度：&quot; +  $(window).height()  );</span><br><span class="line">        ata();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="html-代码"><a href="#html-代码" class="headerlink" title="html 代码"></a>html 代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;content&quot;&gt;</span><br><span class="line">        &lt;p&gt;佛系前端&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;佛系前端&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;佛系前端&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;佛系前端&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;佛系前端&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;佛系前端&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;佛系前端&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;佛系前端&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;佛系前端&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;佛系前端&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;佛系前端&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;佛系前端&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;佛系前端&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;佛系前端&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;佛系前端&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;佛系前端&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;佛系前端&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;佛系前端&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;佛系前端&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;佛系前端&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;佛系前端&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div id=&quot;container&quot;&gt;&lt;/div&gt; //加载数据的位置</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h3 id="css-代码"><a href="#css-代码" class="headerlink" title="css 代码"></a>css 代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">html,body&#123;</span><br><span class="line">    font-size: 37.5px;</span><br><span class="line">    overflow-y: auto;</span><br><span class="line">    overflow-x: hidden;</span><br><span class="line">    /* width:100%;</span><br><span class="line">    height:100%; */     // 在手机端当 html,body&#123;width:100%;height:100%;&#125; 绑定在window无法触发 onscroll 和 scroll，即 jq 和 js 都不会触发scroll事件！</span><br><span class="line">     /* -webkit-overflow-scrolling: touch; */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：在手机开发中，当 html,body 设置为 {width:100%;height:100%;} 的时候，绑定在 window 无法触发 onscroll 和 scroll，即 jq 和 js 都不会触发scroll事件！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍了手机端基于javascript实现浏览器滚动条快到底部时自动加载数据，绑定在 window 无法触发 onscroll 和 scroll的问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="手机开发" scheme="http://yoursite.com/tags/%E6%89%8B%E6%9C%BA%E5%BC%80%E5%8F%91/"/>
    
      <category term="js滚动加载问题" scheme="http://yoursite.com/tags/js%E6%BB%9A%E5%8A%A8%E5%8A%A0%E8%BD%BD%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>前端检测是否电脑端/移动端</title>
    <link href="http://yoursite.com/2018/06/10/%E6%A3%80%E6%B5%8B%E6%98%AF%E5%90%A6%E7%94%B5%E8%84%91%E7%AB%AF-%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    <id>http://yoursite.com/2018/06/10/检测是否电脑端-移动端/</id>
    <published>2018-06-10T10:41:41.000Z</published>
    <updated>2018-06-16T06:01:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍如何在日常开发中检测是否电脑端/移动端。</p><a id="more"></a><h3 id="废话不多说，直接看代码！"><a href="#废话不多说，直接看代码！" class="headerlink" title="废话不多说，直接看代码！"></a>废话不多说，直接看代码！</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var browser = &#123;</span><br><span class="line">    versions: function() &#123;</span><br><span class="line">        var u = navigator.userAgent,</span><br><span class="line">            app = navigator.appVersion;</span><br><span class="line"></span><br><span class="line">        return &#123;</span><br><span class="line">            trident: u.indexOf(&quot;Trident&quot;) &gt; -1,</span><br><span class="line">            presto: u.indexOf(&quot;Presto&quot;) &gt; -1,</span><br><span class="line">            isChrome: u.indexOf(&quot;chrome&quot;) &gt; -1,</span><br><span class="line">            isSafari: !u.indexOf(&quot;chrome&quot;) &gt; -1 &amp;&amp; (/webkit|khtml/).test(u),</span><br><span class="line">            isSafari3: !u.indexOf(&quot;chrome&quot;) &gt; -1 &amp;&amp; (/webkit|khtml/).test(u) &amp;&amp; u.indexOf(&quot;webkit/5&quot;) != -1,</span><br><span class="line">            webKit: u.indexOf(&quot;AppleWebKit&quot;) &gt; -1,</span><br><span class="line">            gecko: u.indexOf(&quot;Gecko&quot;) &gt; -1 &amp;&amp; u.indexOf(&quot;KHTML&quot;) == -1,</span><br><span class="line">            mobile: !!u.match(/AppleWebKit.*Mobile.*/),</span><br><span class="line">            ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/),</span><br><span class="line">            android: u.indexOf(&quot;Android&quot;) &gt; -1 || u.indexOf(&quot;Linux&quot;) &gt; -1,</span><br><span class="line">            iPhone: u.indexOf(&quot;iPhone&quot;) &gt; -1,</span><br><span class="line">            iPad: u.indexOf(&quot;iPad&quot;) &gt; -1,</span><br><span class="line">            iWinPhone: u.indexOf(&quot;Windows Phone&quot;) &gt; -1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if( browser.versions.mobile() || browser.versions.ios() || browser.versions.android() || browser.versions.iPhone() || browser.versions.iPad() ) &#123;</span><br><span class="line">    alert( &quot;移动端&quot; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍如何在日常开发中检测是否电脑端/移动端。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端开发" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="移动端开发" scheme="http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="浏览器检测" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>js滚动条底部自动加载</title>
    <link href="http://yoursite.com/2018/06/03/js%E6%BB%9A%E5%8A%A8%E6%9D%A1%E5%BA%95%E9%83%A8%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD/"/>
    <id>http://yoursite.com/2018/06/03/js滚动条底部自动加载/</id>
    <published>2018-06-03T12:32:14.000Z</published>
    <updated>2018-06-16T06:26:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍了基于javascript实现浏览器滚动条快到底部时自动加载数据的相关资料。</p><a id="more"></a><h3 id="js-代码"><a href="#js-代码" class="headerlink" title="js 代码"></a>js 代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$(function()&#123;</span><br><span class="line">    var totalHeight = 0; //定义一个总高度变量</span><br><span class="line">    function ata()&#123; //loa动态加载数据</span><br><span class="line">        totalHeight =  parseFloat( $(window).height() ) +  parseFloat( $(window).scrollTop() ); //浏览器的高度加上滚动条的高度</span><br><span class="line">        if( $(document).height() &lt;= totalHeight ) &#123; //当文档的高度小于或者等于总的高度时，开始动态加载数据</span><br><span class="line">            $( &quot;#container&quot; ).append( &quot;&lt;p&gt;我是新加载出来的数据&lt;/p&gt;&quot; ); //加载数据</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    $(window).scroll(function()&#123;</span><br><span class="line">        console.log( &quot;滚动条到顶部的垂直高度：&quot; +  $(window).scrollTop()  );</span><br><span class="line">        console.log( &quot;页面的文档高度：&quot; +  $(document).height()  );</span><br><span class="line">        console.log( &quot;浏览器的高度：&quot; +  $(window).height()  );</span><br><span class="line">        ata();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="html-代码"><a href="#html-代码" class="headerlink" title="html 代码"></a>html 代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;pa&quot;&gt;</span><br><span class="line">        &lt;p&gt;1&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;1&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;1&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;1&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;1&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;1&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;1&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;1&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;1&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;1&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;1&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;1&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;1&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;1&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;4&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;1&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;1&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;1&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;1&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;1&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;1&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div id=&quot;container&quot;&gt;&lt;/div&gt; //加载数据的位置</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍了基于javascript实现浏览器滚动条快到底部时自动加载数据的相关资料。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js滚动加载" scheme="http://yoursite.com/tags/js%E6%BB%9A%E5%8A%A8%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>部份手机(ios8、ios9) clipboard.min.js 跳出多次复制成功的问题及其解决</title>
    <link href="http://yoursite.com/2018/05/20/%E9%83%A8%E4%BB%BD%E6%89%8B%E6%9C%BA-ios8%E3%80%81ios9-clipboard-min-js-%E8%B7%B3%E5%87%BA%E5%A4%9A%E6%AC%A1%E5%A4%8D%E5%88%B6%E6%88%90%E5%8A%9F%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3/"/>
    <id>http://yoursite.com/2018/05/20/部份手机-ios8、ios9-clipboard-min-js-跳出多次复制成功的问题及其解决/</id>
    <published>2018-05-20T14:20:16.000Z</published>
    <updated>2018-05-20T14:35:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>手机开发：clipboard.min.js 跳出多次复制成功的问题及其解决。</p><a id="more"></a><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>第一次进来打开页面弹窗，点击 <code>复制按钮</code> 弹出提示 <code>复制成功</code> 这是没问题的，但是关闭弹窗（这时候的弹窗是 remove 掉的）再打开弹窗，再次点击复制的时候会弹出两次复制成功 ，根据代码调试实践总结这是因为第一次来 <code>var copy = new Clipboard( elem )</code> 的时候实例化了一次，第二次再打开弹窗再点击复制的时候又 <code>var copy = new Clipboard( elem )</code>  了一次，所以说再次点击会弹出两次 复制成功，如果每次关闭弹窗前不去销毁  <code>copy</code> 这一实例的话，每次打开弹窗就会实例化 +1，所以要想解决这个问题的话必须每次关掉弹窗的时候要销毁这一实例。具体的实现方法参考下面的代码：</p><h3 id="部份代码示例"><a href="#部份代码示例" class="headerlink" title="部份代码示例"></a>部份代码示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"># htm</span><br><span class="line">&lt;script type=&quot;text/template&quot; id=&quot;tplCardNum&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;vodal-card vodal-common&quot;&gt;</span><br><span class="line">        &lt;span class=&quot;icon-bei&quot;&gt;&lt;/span&gt;</span><br><span class="line">        &lt;h3&gt;恭喜您获得&lt;span&gt;【&#123;$gift_name&#125;】&lt;/span&gt;&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">        &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; align=&quot;center&quot; class=&quot;vodal-card-table&quot;&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td width=&quot;30%&quot;&gt;礼包序列号&lt;/td&gt;</span><br><span class="line">                &lt;td width=&quot;40%&quot; class=&quot;break-word&quot;&gt;&#123;$activation_code&#125;&lt;/td&gt;</span><br><span class="line">                &lt;td width=&quot;30%&quot;&gt;&lt;a href=&quot;javascript:;&quot; data-clipboard-text=&quot;&#123;$activation_code&#125;&quot; id=&quot;vodalCardCopy_&#123;$activation_code&#125;&quot; class=&quot;btn stroke&quot;&gt;复制&lt;/a&lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">        &lt;/table&gt;</span><br><span class="line"></span><br><span class="line">        &lt;p class=&quot;card-tips&quot;&gt;请在今天内登录游戏进行领取&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"># js</span><br><span class="line">var t = &#123;</span><br><span class="line">    copyCache: &#123;&#125;,</span><br><span class="line">    copy: function( elem ) &#123;</span><br><span class="line">        var _this = this;</span><br><span class="line">        _this.copyCache[elem] = new Clipboard( elem );</span><br><span class="line"></span><br><span class="line">        _this.copyCache[elem].on( &quot;success&quot;, function( e ) &#123;</span><br><span class="line">            $( elem ).text( &quot;已复制&quot; );</span><br><span class="line">            e.clearSelection();</span><br><span class="line">        &#125; );</span><br><span class="line">        _this.copyCache[elem].on( &quot;error&quot;, function(a) &#123;</span><br><span class="line">            $.signDialog.alert( &quot;由于系统不支持，请手动复制礼包码&quot; );</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    _getMyReward: function() &#123;</span><br><span class="line">        var _this = this;</span><br><span class="line"></span><br><span class="line">        $.signUtil.callApi( &#123;</span><br><span class="line">            url: &quot;url&quot;,</span><br><span class="line">            type: &quot;post&quot;,</span><br><span class="line">            successCall: function( res ) &#123;</span><br><span class="line">                if( res ) &#123;</span><br><span class="line">                    if( +res.code === 1 ) &#123;</span><br><span class="line">                        if( res.data.length &gt; 0 ) &#123;</span><br><span class="line">                            $.signDialog(&#123;</span><br><span class="line">                                content: $.signUtil.getHtml( _this.tplRewardMy, &#123;</span><br><span class="line">                                    REWARD_CONTENT: $.sdkUtil.T( _this.tplRewardTr, res.data )</span><br><span class="line">                                &#125; ),</span><br><span class="line">                                closeBtnState: true,</span><br><span class="line">                                dialogWidth: &quot;80%&quot;,</span><br><span class="line">                                buttons: &#123;</span><br><span class="line">                                    &quot;确定&quot;: &#123;</span><br><span class="line">                                        class: &quot;vodal-confirm-btn&quot;,</span><br><span class="line">                                        fn: function( name, obj ) &#123;</span><br><span class="line">                                            obj.destroy();</span><br><span class="line"></span><br><span class="line">                                            // 关闭弹窗，销毁 Clipboard 复制，不然有些手机（ios8、ios9）会重复复制</span><br><span class="line">                                            for( var i = 0, len = res.data.length; i &lt; len; i++ ) &#123;</span><br><span class="line">                                                (function(j) &#123;</span><br><span class="line">                                                    _this.copyCache[&quot;#vodalCardCopy_&quot; + res.data[j].activation_code].destroy();</span><br><span class="line">                                                &#125;)(i);</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line"></span><br><span class="line">                            for( var i = 0, len = res.data.length; i &lt; len; i++ ) &#123;</span><br><span class="line">                                (function(j) &#123;</span><br><span class="line">                                    _this.copy( &quot;#vodalCardCopy_&quot; + res.data[j].activation_code );</span><br><span class="line">                                &#125;)(i);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            alert( &quot;您暂时还没有奖品~&quot; );</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        alert( res.message );</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;手机开发：clipboard.min.js 跳出多次复制成功的问题及其解决。&lt;/p&gt;
    
    </summary>
    
    
      <category term="手机开发" scheme="http://yoursite.com/tags/%E6%89%8B%E6%9C%BA%E5%BC%80%E5%8F%91/"/>
    
      <category term="clipboard.min.js" scheme="http://yoursite.com/tags/clipboard-min-js/"/>
    
  </entry>
  
  <entry>
    <title>微信浏览器左上角返回按钮的监听</title>
    <link href="http://yoursite.com/2018/05/20/%E5%BE%AE%E4%BF%A1%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A6%E4%B8%8A%E8%A7%92%E8%BF%94%E5%9B%9E%E6%8C%89%E9%92%AE%E7%9A%84%E7%9B%91%E5%90%AC/"/>
    <id>http://yoursite.com/2018/05/20/微信浏览器左上角返回按钮的监听/</id>
    <published>2018-05-20T14:08:20.000Z</published>
    <updated>2018-05-20T14:13:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>微信开发的时候，在公众号菜单中打开一个H5页面(如：个人中心)，在这个页面上的一些操作，经过多次跳转后，点击左上角的返回按钮，发现会原封不动的返回至上一级页面。这时，我们可以通过微信浏览器左上角返回按钮的监听，去到指定的页面。</p><a id="more"></a><h3 id="点击微信浏览器左上角返回按钮，指定跳到对应的页面"><a href="#点击微信浏览器左上角返回按钮，指定跳到对应的页面" class="headerlink" title="点击微信浏览器左上角返回按钮，指定跳到对应的页面"></a>点击微信浏览器左上角返回按钮，指定跳到对应的页面</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if( history &amp;&amp; history.pushState ) &#123;</span><br><span class="line">    history.pushState( &#123;</span><br><span class="line">        title: document.title,</span><br><span class="line">        url: location.href</span><br><span class="line">    &#125;, document.title, location.href );</span><br><span class="line">&#125;</span><br><span class="line">//添加退弹事件</span><br><span class="line">window.addEventListener( &quot;popstate&quot;, function( e ) &#123;</span><br><span class="line">    alert( &quot;我监听到了浏览器的返回按钮事件啦&quot; );</span><br><span class="line">    location.href = &quot;你要跳转的链接&quot;;  //在这里指定其返回的地址</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure><h4 id="点击微信浏览器左上角返回按钮，关闭当前页面返回到微信公众号"><a href="#点击微信浏览器左上角返回按钮，关闭当前页面返回到微信公众号" class="headerlink" title="点击微信浏览器左上角返回按钮，关闭当前页面返回到微信公众号"></a>点击微信浏览器左上角返回按钮，关闭当前页面返回到微信公众号</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if( history &amp;&amp; history.pushState ) &#123;</span><br><span class="line">    history.pushState( &#123;</span><br><span class="line">        title: document.title,    // 默认当前 title 即可</span><br><span class="line">        url: location.href        // 默认当前 url 即可</span><br><span class="line">    &#125;, document.title, location.href );</span><br><span class="line">&#125;</span><br><span class="line">//添加退弹事件</span><br><span class="line">window.addEventListener( &quot;popstate&quot;, function( e ) &#123;</span><br><span class="line">    if( WeixinJSBridge ) &#123;</span><br><span class="line">        WeixinJSBridge.call( &quot;closeWindow&quot; );   // 关闭当前页面返回到公众号</span><br><span class="line">    &#125;</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微信开发的时候，在公众号菜单中打开一个H5页面(如：个人中心)，在这个页面上的一些操作，经过多次跳转后，点击左上角的返回按钮，发现会原封不动的返回至上一级页面。这时，我们可以通过微信浏览器左上角返回按钮的监听，去到指定的页面。&lt;/p&gt;
    
    </summary>
    
    
      <category term="微信开发" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>浏览器的一个请求从发送到返回都经历了什么</title>
    <link href="http://yoursite.com/2018/05/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82%E4%BB%8E%E5%8F%91%E9%80%81%E5%88%B0%E8%BF%94%E5%9B%9E%E9%83%BD%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <id>http://yoursite.com/2018/05/16/浏览器的一个请求从发送到返回都经历了什么/</id>
    <published>2018-05-16T03:36:28.000Z</published>
    <updated>2018-05-16T03:36:28.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HTTP网络协议</title>
    <link href="http://yoursite.com/2018/05/13/HTTP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/2018/05/13/HTTP网络协议/</id>
    <published>2018-05-13T13:34:31.000Z</published>
    <updated>2018-05-13T13:55:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写，是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。<br>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。<br>HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。</p><a id="more"></a><h3 id="HTTP-工作过程"><a href="#HTTP-工作过程" class="headerlink" title="HTTP 工作过程"></a>HTTP 工作过程</h3><p><img src="https://upload-images.jianshu.io/upload_images/1856419-9279a850818a10ba.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/551" alt="HTTP请求响应模型"></p><p>HTTP通信机制是在一次完整的 HTTP 通信过程中，客户端与服务器之间将完成下列7个步骤：</p><h5 id="1、建立-TCP-连接"><a href="#1、建立-TCP-连接" class="headerlink" title="1、建立 TCP 连接"></a>1、建立 TCP 连接</h5><p>在HTTP工作开始之前，客户端首先要通过网络与服务器建立连接，该连接是通过 TCP 来完成的，该协议与 IP 协议共同构建 Internet，即著名的 TCP/IP 协议族，因此 Internet 又被称作是 TCP/IP 网络。HTTP 是比 TCP 更高层次的应用层协议，根据规则，只有低层协议建立之后，才能进行高层协议的连接，因此，首先要建立 TCP 连接，一般 TCP 连接的端口号是80；</p><h5 id="2、客户端向服务器发送请求命令"><a href="#2、客户端向服务器发送请求命令" class="headerlink" title="2、客户端向服务器发送请求命令"></a>2、客户端向服务器发送请求命令</h5><p>一旦建立了TCP连接，客户端就会向服务器发送请求命令；<br>例如：<code>GET/sample/hello.jsp HTTP/1.1</code></p><h5 id="3、客户端发送请求头信息"><a href="#3、客户端发送请求头信息" class="headerlink" title="3、客户端发送请求头信息"></a>3、客户端发送请求头信息</h5><p>客户端发送其请求命令之后，还要以头信息的形式向服务器发送一些别的信息，之后客户端发送了一空白行来通知服务器，它已经结束了该头信息的发送；</p><h5 id="4、服务器应答"><a href="#4、服务器应答" class="headerlink" title="4、服务器应答"></a>4、服务器应答</h5><p>客户端向服务器发出请求后，服务器会客户端返回响应；<br>例如： <code>HTTP/1.1 200 OK</code><br>响应的第一部分是协议的版本号和响应状态码</p><h5 id="5、服务器返回响应头信息"><a href="#5、服务器返回响应头信息" class="headerlink" title="5、服务器返回响应头信息"></a>5、服务器返回响应头信息</h5><p>正如客户端会随同请求发送关于自身的信息一样，服务器也会随同响应向用户发送关于它自己的数据及被请求的文档；</p><h5 id="6、服务器向客户端发送数据"><a href="#6、服务器向客户端发送数据" class="headerlink" title="6、服务器向客户端发送数据"></a>6、服务器向客户端发送数据</h5><p>服务器向客户端发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以 <code>Content-Type</code> 响应头信息所描述的格式发送用户所请求的实际数据；</p><h5 id="7、服务器关闭-TCP-连接"><a href="#7、服务器关闭-TCP-连接" class="headerlink" title="7、服务器关闭 TCP 连接"></a>7、服务器关闭 TCP 连接</h5><p>一般情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接，然后如果客户端或者服务器在其头信息加入了这行代码 <code>Connection:keep-alive</code> ，TCP 连接在发送后将仍然保持打开状态，于是，客户端可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写，是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。&lt;br&gt;HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。&lt;br&gt;HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络基础知识" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="HTTP网络协议" scheme="http://yoursite.com/tags/HTTP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>TCP（Transmission Control Protocol，传输控制协议）</title>
    <link href="http://yoursite.com/2018/05/12/TCP/"/>
    <id>http://yoursite.com/2018/05/12/TCP/</id>
    <published>2018-05-12T08:59:18.000Z</published>
    <updated>2018-05-12T09:40:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>TCP是一种面向连接（连接导向）的、可靠的基于字节流的传输层通信协议。TCP将用户数据打包成报文段，它发送后启动一个定时器，另一端收到的数据进行确认、对失序的数据重新排序、丢弃重复数据。</p><a id="more"></a><h3 id="TCP的特点有："><a href="#TCP的特点有：" class="headerlink" title="TCP的特点有："></a>TCP的特点有：</h3><ul><li>TCP是面向连接的运输层协议</li><li>每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的</li><li>TCP提供可靠交付的服务</li><li>TCP提供全双工通信。数据在两个方向上独立的进行传输。因此，连接的每一端必须保持每个方向上的传输数据序号。</li><li>面向字节流。面向字节流的含义：虽然应用程序和TCP交互是一次一个数据块，但TCP把应用程序交下来的数据仅仅是一连串的无结构的字节流。</li></ul><h4 id="1、TCP头格式"><a href="#1、TCP头格式" class="headerlink" title="1、TCP头格式"></a>1、TCP头格式</h4><ul><li>（1）Source Port（源端口号）：数据发起者的端口号，16bit。</li><li>（2）Destination Port（目的端口号）：数据接收者的端口号，16bit。</li><li>（3）Sequence Number（顺序号码，Seq）：用于在数据通信中解决网络包乱序（reordering）问题，以保证应用层接收到的数据不会因为网络上的传输问题而乱序（TCP会用这个顺序号码来拼接数据），32bit。</li><li>（4）Acknowledgment Number（确认号码，ack）：是数据接收方期望收到发送方在下一个报文段的顺序号码（Seq），因此确认号码应当是上次已成功收到顺序号码（Seq）加1，32bit。</li><li>（5）Offset（TCP报文头长度)：用于存储报文头中有多少个32bit(上图的一行)，存储长度为4bit，最大可表示（2^3+2^2+2^1+1）<em>32bit=60bytes的报文头。最小取值5，5</em>32bit=20bytes。</li><li>（6）Reserved（保留）：6bit, 均为0</li><li>（7）TCP Flags（TCP标志位）每个长度均为1bit<ul><li>CWR：压缩，TCP Flags值0x80。</li><li>ECE：拥塞，0x40。</li><li>URG：紧急，0x20。当URG=1时，表示报文段中有紧急数据，应尽快传送。</li><li>ACK：确认，0x10。当ACK = 1时，代表这是一个确认的TCP包，取值0则不是确认包。</li><li>PSH：推送，0x08。当发送端PSH=1时，接收端尽快的交付给应用进程。</li><li>RST：复位，0x04。当RST=1时，表明TCP连接中出现严重差错，必须释放连接，再重新建立连接。</li><li>SYN：同步，0x02。在建立连接是用来同步序号。SYN=1， ACK=0表示一个连接请求报文段。SYN=1，ACK=1表示同意建立连接。</li><li>FIN：终止，0x01。当FIN=1时，表明此报文段的发送端的数据已经发送完毕，并要求释放传输连接。</li></ul></li><li>（8）窗口：用来控制对方发送的数据量，通知发放已确定的发送窗口上限。</li><li>（9）检验和：该字段检验的范围包括头部和数据这两部分。由发端计算和存储，并由收端进行验证。</li><li>（10）紧急指针：紧急指针在URG=1时才有效，它指出本报文段中的紧急数据的字节数。</li><li><p>（11）TCP选项：长度可变，最长可达40字节</p><h4 id="2、TCP协议中的三次握手和四次挥手"><a href="#2、TCP协议中的三次握手和四次挥手" class="headerlink" title="2、TCP协议中的三次握手和四次挥手"></a>2、TCP协议中的三次握手和四次挥手</h4><p><img src="https://upload-images.jianshu.io/upload_images/1641067-cfbdc82ef9f5c5c0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/546" alt="TCP协议中的三次握手和四次挥手"></p></li></ul><ul><li>Seq：是发送方当前报文的顺序号码。</li><li>ack：是发送方期望对方在下次返回报文中给回的Seq。</li></ul><p>建立连接需要三次握手<br>第一次握手：客户端向服务端发送连接请求包，标志位SYN（同步序号）置为1，顺序号码为X=0。</p><p>第二次握手：服务端收到客户端发过来报文，由SYN=1知道客户端要求建立联机，则为这次连接分配资源。并向客户端发送一个SYN和ACK都置为1的TCP报文，设置初始顺序号码Y=0，将确认序号(ack)设置为上一次客户端发送过来的顺序号(Seq)加1，即X+1 = 0+1=1。</p><p>第三次握手：客户端收到服务端发来的包后检查确认号码(ack)是否正确，即第一次发送的Seq加1（X+1=1）。以及标志位ACK是否为1。若正确，服务端再次发送确认包，ACK标志位为1，SYN标志位为0。确认号码(ack)=Y+1=0+1=1，发送顺序号码(Seq)为X+1=1。Server收到后确认号码值与ACK=1则连接建立成功，可以传送数据了。</p><p>断开连接需要四次挥手<br>提醒：中断连接端可以是Client端，也可以是Server端。只要将下面两角色互换即可。<br>第一次挥手：客户端给服务端发送FIN报文，用来关闭客户端到服务端的数据传送。将标志位FIN和ACK置为1，顺序号码为X=1，确认号码为Z=1。意思是说”我Client端没有数据要发给你了，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK过来。”</p><p>第二次挥手：服务端收到FIN后，发回一个ACK(标志位ACK=1),确认号码为收到的顺序号码加1，即X=X+1=2。顺序号码为收到的确认号码=Z。意思是说“你的FIN请求我收到了，但是我还没准备好，请继续你等我的消息” 这个时候客户端就进入FIN_WAIT状态，继续等待服务端的FIN报文。</p><p>第三次挥手：当服务端确定数据已发送完成，则向客户端发送FIN报文，关闭与客户端的连接。标志位FIN和ACK置为1，顺序号码为Y=1，确认号码为X=2。意思是告诉Client端“好了，我这边数据发完了，准备好关闭连接了。”</p><p>第四次挥手：客户端收到服务器发送的FIN之后，发回ACK确认(标志位ACK=1),确认号码为收到的顺序号码加1，即Y+1=2。顺序号码为收到的确认号码X=2。意思是“我Client端知道可以关闭连接了，但是我还是不相信网络，怕 Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。“（在TIME_WAIT状态中，如果TCP client端最后一次发送的ACK丢失了，它将重新发送。TIME_WAIT状态中所需要的时间是依赖于实现方法的。典型的值为30秒、1分钟和2分钟。等待之后连接正式关闭，并且所有的资源(包括端口号)都被释放。）</p><p>为什么关闭的时候却是四次挥（握）手？<br>因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TCP是一种面向连接（连接导向）的、可靠的基于字节流的传输层通信协议。TCP将用户数据打包成报文段，它发送后启动一个定时器，另一端收到的数据进行确认、对失序的数据重新排序、丢弃重复数据。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络基础知识" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="TCP" scheme="http://yoursite.com/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>前端性能衡量指标</title>
    <link href="http://yoursite.com/2018/03/21/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E8%A1%A1%E9%87%8F%E6%8C%87%E6%A0%87/"/>
    <id>http://yoursite.com/2018/03/21/前端性能衡量指标/</id>
    <published>2018-03-21T15:11:07.000Z</published>
    <updated>2018-03-21T15:18:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍前端性能衡量指标，对于一个网站如果希望抓住用户，网站的速度以及稳定性是非常重要的。</p><a id="more"></a><h2 id="性能衡量指标"><a href="#性能衡量指标" class="headerlink" title="性能衡量指标"></a>性能衡量指标</h2><p><strong>指标：</strong></p><ul><li>白屏时间</li><li>首屏时间</li><li>用户可交互时间</li><li>完全加载时间</li><li>首字节时间</li><li>DNS 解析时间</li><li>TCP 连接时间</li><li>HTTP 请求时间</li><li>HTTP 响应时间</li></ul><p><strong>维度：</strong></p><ul><li>运营商</li><li>网络</li><li>URL</li></ul><h2 id="性能监控"><a href="#性能监控" class="headerlink" title="性能监控"></a>性能监控</h2><p><strong>如何监控</strong></p><ul><li><a href="https://link.juejin.im/?target=http%3A%2F%2Ffex.baidu.com%2Fblog%2F2014%2F05%2Fbuild-performance-monitor-in-7-days%2F" target="_blank" rel="noopener">7 天打造前端性能监控系统</a></li><li><a href="https://link.juejin.im/?target=http%3A%2F%2Fweb.jobbole.com%2F84264%2F" target="_blank" rel="noopener">使用性能API快速分析web前端性能</a></li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F37585246" target="_blank" rel="noopener">你是如何搭建 Web 前端性能监控系统的</a></li></ul><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p><strong>优化点：</strong></p><ul><li>高频事件消抖、节流。使用<em>.debounce()和</em>. throttle()，控制高频事件的操作，如：scroll、onChange<ul><li>_.debounce()的多次连续的调用，最终实际上只会调用一次；</li><li>_. throttle()将频繁调用的函数限定在一个给定的调用频率内。</li></ul></li><li>JavaScritp很快，但是DOM很慢，减少修改DOM。<ul><li>DOM的渲染需要计算DOM+CSSOM，每次DOM和CSSOM的每次修改都会触发重绘；<ul><li>渲染过程：JavaScript -&gt; Style -&gt; Layoout -&gt; Paint -&gt; Composite</li></ul></li><li>避免 position: fixed;布局，Z轴图层堆叠关系会改变，引起重绘；</li><li>图层隔离：将那些会变动的元素提升至单独的图层，比如：动画、渐变；</li><li>降低图层复杂度；</li><li>避免线程阻塞；</li><li>优化CSS；</li><li>文件：引入方式、位置、文件合并、延迟加载；</li><li>硬件加速：GPU加速渲染</li></ul></li></ul><p><strong>基于各环节优化：</strong><br><img src="https://upload-images.jianshu.io/upload_images/1726248-530cd1c4fe65d9e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="优化流程"></p><ul><li>减少http请求，合理设置 HTTP缓存</li><li>使用HTTP/2</li><li>持久连接，使用 keep-alive 或者 WebSocket</li><li>使用浏览器缓存</li><li>启用压缩</li><li>CSS Sprites</li><li>LazyLoad Images</li><li>样式文件放在顶部，脚本文件放在底部</li><li>减少 cookie 传输</li><li>CDN 加速<ul><li>CDN（contentdistribute network，内容分发网络）的本质仍然是一个缓存，而且将数据缓存在离用户最近的地方，使用户以最快速度获取数据，即所谓网络访问第一跳。</li></ul></li><li>反向代理<ul><li>传统代理服务器位于浏览器一侧，代理浏览器将http请求发送到互联网上，而反向代理服务器位于网站机房一侧，代理网站web服务器接收http请求。</li><li>论坛网站，把热门词条、帖子、博客缓存在反向代理服务器上加速用户访问速度，当这些动态内容有变化时，通过内部通知机制通知反向代理缓存失效，反向代理会重新加载最新的动态内容再次缓存起来。</li><li>此外，反向代理也可以实现负载均衡的功能，而通过负载均衡构建的应用集群可以提高系统总体处理能力，进而改善网站高并发情况下的性能。</li></ul></li><li>面向未来，考虑 service worker</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍前端性能衡量指标，对于一个网站如果希望抓住用户，网站的速度以及稳定性是非常重要的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端开发" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="前端优化" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>hexo部署到github</title>
    <link href="http://yoursite.com/2018/03/21/hexo%E9%83%A8%E7%BD%B2%E5%88%B0github/"/>
    <id>http://yoursite.com/2018/03/21/hexo部署到github/</id>
    <published>2018-03-21T07:58:43.000Z</published>
    <updated>2019-03-25T03:20:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍如何成功搭建hexo本地博客并部署到github上。</p><a id="more"></a><h3 id="一、首先搭建-hexo-本地博客"><a href="#一、首先搭建-hexo-本地博客" class="headerlink" title="一、首先搭建 hexo 本地博客"></a>一、首先搭建 hexo 本地博客</h3><p>1、git和Node.js都安装成功后，安装hexo，命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install hexo -g</span><br></pre></td></tr></table></figure></p><p>2、创建 my-hexo 文件夹，命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir my-hexo</span><br></pre></td></tr></table></figure></p><p>3、my-hexo 安装成功后，在该文件夹下执行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure></p><p>4、启动本地服务，现在已经搭建起本地的 hexo 博客了，执行以下命令，然后到浏览器输入 <code>localhost:4000</code> 查看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate 或 hexo g    // 生成静态文件</span><br><span class="line">hexo server 或 hexo s        // 启动服务器。默认情况下，访问网址为： http://localhost:4000/</span><br></pre></td></tr></table></figure></p><p>5、到此，本地博客已经搭建起来了，如下图（这是添加了文章，换了主题的博客）<br><img src="https://upload-images.jianshu.io/upload_images/1726248-7e71fb085f79722c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="我的博客"></p><h3 id="二、将-hexo-本地博客部署到github上"><a href="#二、将-hexo-本地博客部署到github上" class="headerlink" title="二、将 hexo 本地博客部署到github上"></a>二、将 hexo 本地博客部署到github上</h3><p>1、创建repository<br>这里的 repository 名必须使用你的github的用户，即我的用户名为 <code>frontend</code> ，那么网址必须为 <code>frontendX.github.io</code> ，如下图（创建repository）中红色框。<br><img src="https://upload-images.jianshu.io/upload_images/1726248-f1b9512f1b4e8e15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建repository"></p><p>2、部署<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 编辑 _config.yml ，在部署时，要把下面的 zippera 都换成你的账号名。</span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repository: https://github.com/frontendX/frontendX.git</span><br><span class="line">    branch: master</span><br><span class="line"></span><br><span class="line"> // 执行下列指令即可完成部署。</span><br><span class="line"></span><br><span class="line"> hexo g</span><br><span class="line"> hexo d</span><br><span class="line"></span><br><span class="line"> 如果提示：ERROR Deployer not found: git</span><br><span class="line"> 执行以下以下命令：npm install hexo-deployer-git --save</span><br><span class="line"></span><br><span class="line"> 完成之后再执行：</span><br><span class="line">    hexo generate</span><br><span class="line">    hexo deploy</span><br></pre></td></tr></table></figure></p><p> <strong>记住：每次修改本地文件后，需要 <code>hexo g</code> 才能保存，<code>hexo d</code> 才能部署到github。每次使用命令时，都要在该项目目录下。</strong></p><p><em>注意：部署中遇到的问题</em></p><p>当 <code>repository</code> 名是 <code>froentendX</code>（修改前 - 1）的时候，<a href="https://frontendx.github.io/" target="_blank" rel="noopener">https://frontendx.github.io/</a> 页面访问不了；需要把 <code>froentendX</code> 修改成 <code>frontendX.github.io</code>（修改后 - 2）<br><img src="https://upload-images.jianshu.io/upload_images/1726248-a80dab99d98acc8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="修改前 - 1"></p><p><img src="https://upload-images.jianshu.io/upload_images/1726248-a3e865480fa01273.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="修改后 - 2"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍如何成功搭建hexo本地博客并部署到github上。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端开发" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="github" scheme="http://yoursite.com/tags/github/"/>
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>ES6：export default 和 export 区别</title>
    <link href="http://yoursite.com/2018/03/21/ES6%EF%BC%9Aexport-default-%E5%92%8C-export-%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2018/03/21/ES6：export-default-和-export-区别/</id>
    <published>2018-03-21T01:55:47.000Z</published>
    <updated>2018-03-21T12:29:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文通过主要介绍export default 和 export 的区别。</p><a id="more"></a><h2 id="export-default-和-export-区别："><a href="#export-default-和-export-区别：" class="headerlink" title="export default 和 export 区别："></a>export default 和 export 区别：</h2><p>1.export与export default均可用于导出常量、函数、文件、模块等<br>2.你可以在其它文件或模块中通过import+(常量 | 函数 | 文件 | 模块)名的方式，将其导入，以便能够对其进行使用<br>3.在一个文件或模块中，export、import可以有多个，export default仅有一个<br>4.通过export方式导出，在导入时要加{ }，export default则不需要</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1.export</span><br><span class="line">//a.js</span><br><span class="line">export const str = &quot;blablabla~&quot;;</span><br><span class="line">export function log(sth) &#123;</span><br><span class="line">  return sth;</span><br><span class="line">&#125;</span><br><span class="line">对应的导入方式：</span><br><span class="line"></span><br><span class="line">//b.js</span><br><span class="line">import &#123; str, log &#125; from &apos;a&apos;; //也可以分开写两次，导入的时候带花括号</span><br><span class="line"></span><br><span class="line">2.export default</span><br><span class="line">//a.js</span><br><span class="line">const str = &quot;blablabla~&quot;;</span><br><span class="line">export default str;</span><br><span class="line">对应的导入方式：</span><br><span class="line"></span><br><span class="line">//b.js</span><br><span class="line">import str from &apos;a&apos;; //导入的时候没有花括号</span><br></pre></td></tr></table></figure><h2 id="使用export-default命令，为模块指定默认输出，这样就不需要知道所要加载模块的变量名"><a href="#使用export-default命令，为模块指定默认输出，这样就不需要知道所要加载模块的变量名" class="headerlink" title="使用export default命令，为模块指定默认输出，这样就不需要知道所要加载模块的变量名"></a>使用export default命令，为模块指定默认输出，这样就不需要知道所要加载模块的变量名</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//a.js</span><br><span class="line">let sex = &quot;boy&quot;;</span><br><span class="line">export default sex（sex不能加大括号）</span><br><span class="line">//原本直接export sex外部是无法识别的，加上default就可以了.但是一个文件内最多只能有一个export default。</span><br><span class="line">其实此处相当于为sex变量值&quot;boy&quot;起了一个系统默认的变量名default，自然default只能有一个值，所以一个文件内不能有多个export default。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// b.js</span><br><span class="line">本质上，a.js文件的export default输出一个叫做default的变量，然后系统允许你为它取任意名字。所以可以为import的模块起任何变量名，且不需要用大括号包含</span><br><span class="line">import any from &quot;./a.js&quot;</span><br><span class="line">import any12 from &quot;./a.js&quot;</span><br><span class="line">console.log(any,any12)   // boy,boy</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文通过主要介绍export default 和 export 的区别。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端开发" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/03/19/hello-world/"/>
    <id>http://yoursite.com/2018/03/19/hello-world/</id>
    <published>2018-03-19T01:55:47.000Z</published>
    <updated>2018-06-10T11:21:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post2"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Clean-files（如果有修改到样式要执行这一步）"><a href="#Clean-files（如果有修改到样式要执行这一步）" class="headerlink" title="Clean files（如果有修改到样式要执行这一步）"></a>Clean files（如果有修改到样式要执行这一步）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端开发" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
</feed>
