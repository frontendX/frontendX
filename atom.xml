<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>佛性前端</title>
  
  <subtitle>你们最喜欢的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-05-20T14:13:50.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>小bbbbbb</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微信浏览器左上角返回按钮的监听</title>
    <link href="http://yoursite.com/2018/05/20/%E5%BE%AE%E4%BF%A1%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A6%E4%B8%8A%E8%A7%92%E8%BF%94%E5%9B%9E%E6%8C%89%E9%92%AE%E7%9A%84%E7%9B%91%E5%90%AC/"/>
    <id>http://yoursite.com/2018/05/20/微信浏览器左上角返回按钮的监听/</id>
    <published>2018-05-20T14:08:20.000Z</published>
    <updated>2018-05-20T14:13:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>微信开发的时候，在公众号菜单中打开一个H5页面(如：个人中心)，在这个页面上的一些操作，经过多次跳转后，点击左上角的返回按钮，发现会原封不动的返回至上一级页面。这时，我们可以通过微信浏览器左上角返回按钮的监听，去到指定的页面。</p><a id="more"></a><h3 id="点击微信浏览器左上角返回按钮，指定跳到对应的页面"><a href="#点击微信浏览器左上角返回按钮，指定跳到对应的页面" class="headerlink" title="点击微信浏览器左上角返回按钮，指定跳到对应的页面"></a>点击微信浏览器左上角返回按钮，指定跳到对应的页面</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if( history &amp;&amp; history.pushState ) &#123;</span><br><span class="line">    history.pushState( &#123;</span><br><span class="line">        title: document.title,</span><br><span class="line">        url: location.href</span><br><span class="line">    &#125;, document.title, location.href );</span><br><span class="line">&#125;</span><br><span class="line">//添加退弹事件</span><br><span class="line">window.addEventListener( &quot;popstate&quot;, function( e ) &#123;</span><br><span class="line">    alert( &quot;我监听到了浏览器的返回按钮事件啦&quot; );</span><br><span class="line">    location.href = &quot;你要跳转的链接&quot;;  //在这里指定其返回的地址</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure><h4 id="点击微信浏览器左上角返回按钮，关闭当前页面返回到微信公众号"><a href="#点击微信浏览器左上角返回按钮，关闭当前页面返回到微信公众号" class="headerlink" title="点击微信浏览器左上角返回按钮，关闭当前页面返回到微信公众号"></a>点击微信浏览器左上角返回按钮，关闭当前页面返回到微信公众号</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if( history &amp;&amp; history.pushState ) &#123;</span><br><span class="line">    history.pushState( &#123;</span><br><span class="line">        title: document.title,    // 默认当前 title 即可</span><br><span class="line">        url: location.href        // 默认当前 url 即可</span><br><span class="line">    &#125;, document.title, location.href );</span><br><span class="line">&#125;</span><br><span class="line">//添加退弹事件</span><br><span class="line">window.addEventListener( &quot;popstate&quot;, function( e ) &#123;</span><br><span class="line">    if( WeixinJSBridge ) &#123;</span><br><span class="line">        WeixinJSBridge.call( &quot;closeWindow&quot; );   // 关闭当前页面返回到公众号</span><br><span class="line">    &#125;</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微信开发的时候，在公众号菜单中打开一个H5页面(如：个人中心)，在这个页面上的一些操作，经过多次跳转后，点击左上角的返回按钮，发现会原封不动的返回至上一级页面。这时，我们可以通过微信浏览器左上角返回按钮的监听，去到指定的页面。&lt;/p&gt;
    
    </summary>
    
    
      <category term="微信开发" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>浏览器的一个请求从发送到返回都经历了什么</title>
    <link href="http://yoursite.com/2018/05/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82%E4%BB%8E%E5%8F%91%E9%80%81%E5%88%B0%E8%BF%94%E5%9B%9E%E9%83%BD%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <id>http://yoursite.com/2018/05/16/浏览器的一个请求从发送到返回都经历了什么/</id>
    <published>2018-05-16T03:36:28.000Z</published>
    <updated>2018-05-16T03:36:28.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HTTP网络协议</title>
    <link href="http://yoursite.com/2018/05/13/HTTP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/2018/05/13/HTTP网络协议/</id>
    <published>2018-05-13T13:34:31.000Z</published>
    <updated>2018-05-13T13:55:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写，是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。<br>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。<br>HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。</p><a id="more"></a><h3 id="HTTP-工作过程"><a href="#HTTP-工作过程" class="headerlink" title="HTTP 工作过程"></a>HTTP 工作过程</h3><p><img src="https://upload-images.jianshu.io/upload_images/1856419-9279a850818a10ba.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/551" alt="HTTP请求响应模型"></p><p>HTTP通信机制是在一次完整的 HTTP 通信过程中，客户端与服务器之间将完成下列7个步骤：</p><h5 id="1、建立-TCP-连接"><a href="#1、建立-TCP-连接" class="headerlink" title="1、建立 TCP 连接"></a>1、建立 TCP 连接</h5><p>在HTTP工作开始之前，客户端首先要通过网络与服务器建立连接，该连接是通过 TCP 来完成的，该协议与 IP 协议共同构建 Internet，即著名的 TCP/IP 协议族，因此 Internet 又被称作是 TCP/IP 网络。HTTP 是比 TCP 更高层次的应用层协议，根据规则，只有低层协议建立之后，才能进行高层协议的连接，因此，首先要建立 TCP 连接，一般 TCP 连接的端口号是80；</p><h5 id="2、客户端向服务器发送请求命令"><a href="#2、客户端向服务器发送请求命令" class="headerlink" title="2、客户端向服务器发送请求命令"></a>2、客户端向服务器发送请求命令</h5><p>一旦建立了TCP连接，客户端就会向服务器发送请求命令；<br>例如：<code>GET/sample/hello.jsp HTTP/1.1</code></p><h5 id="3、客户端发送请求头信息"><a href="#3、客户端发送请求头信息" class="headerlink" title="3、客户端发送请求头信息"></a>3、客户端发送请求头信息</h5><p>客户端发送其请求命令之后，还要以头信息的形式向服务器发送一些别的信息，之后客户端发送了一空白行来通知服务器，它已经结束了该头信息的发送；</p><h5 id="4、服务器应答"><a href="#4、服务器应答" class="headerlink" title="4、服务器应答"></a>4、服务器应答</h5><p>客户端向服务器发出请求后，服务器会客户端返回响应；<br>例如： <code>HTTP/1.1 200 OK</code><br>响应的第一部分是协议的版本号和响应状态码</p><h5 id="5、服务器返回响应头信息"><a href="#5、服务器返回响应头信息" class="headerlink" title="5、服务器返回响应头信息"></a>5、服务器返回响应头信息</h5><p>正如客户端会随同请求发送关于自身的信息一样，服务器也会随同响应向用户发送关于它自己的数据及被请求的文档；</p><h5 id="6、服务器向客户端发送数据"><a href="#6、服务器向客户端发送数据" class="headerlink" title="6、服务器向客户端发送数据"></a>6、服务器向客户端发送数据</h5><p>服务器向客户端发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以 <code>Content-Type</code> 响应头信息所描述的格式发送用户所请求的实际数据；</p><h5 id="7、服务器关闭-TCP-连接"><a href="#7、服务器关闭-TCP-连接" class="headerlink" title="7、服务器关闭 TCP 连接"></a>7、服务器关闭 TCP 连接</h5><p>一般情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接，然后如果客户端或者服务器在其头信息加入了这行代码 <code>Connection:keep-alive</code> ，TCP 连接在发送后将仍然保持打开状态，于是，客户端可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写，是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。&lt;br&gt;HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。&lt;br&gt;HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络基础知识" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="HTTP网络协议" scheme="http://yoursite.com/tags/HTTP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>TCP（Transmission Control Protocol，传输控制协议）</title>
    <link href="http://yoursite.com/2018/05/12/TCP/"/>
    <id>http://yoursite.com/2018/05/12/TCP/</id>
    <published>2018-05-12T08:59:18.000Z</published>
    <updated>2018-05-12T09:40:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>TCP是一种面向连接（连接导向）的、可靠的基于字节流的传输层通信协议。TCP将用户数据打包成报文段，它发送后启动一个定时器，另一端收到的数据进行确认、对失序的数据重新排序、丢弃重复数据。</p><a id="more"></a><h3 id="TCP的特点有："><a href="#TCP的特点有：" class="headerlink" title="TCP的特点有："></a>TCP的特点有：</h3><ul><li>TCP是面向连接的运输层协议</li><li>每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的</li><li>TCP提供可靠交付的服务</li><li>TCP提供全双工通信。数据在两个方向上独立的进行传输。因此，连接的每一端必须保持每个方向上的传输数据序号。</li><li>面向字节流。面向字节流的含义：虽然应用程序和TCP交互是一次一个数据块，但TCP把应用程序交下来的数据仅仅是一连串的无结构的字节流。</li></ul><h4 id="1、TCP头格式"><a href="#1、TCP头格式" class="headerlink" title="1、TCP头格式"></a>1、TCP头格式</h4><ul><li>（1）Source Port（源端口号）：数据发起者的端口号，16bit。</li><li>（2）Destination Port（目的端口号）：数据接收者的端口号，16bit。</li><li>（3）Sequence Number（顺序号码，Seq）：用于在数据通信中解决网络包乱序（reordering）问题，以保证应用层接收到的数据不会因为网络上的传输问题而乱序（TCP会用这个顺序号码来拼接数据），32bit。</li><li>（4）Acknowledgment Number（确认号码，ack）：是数据接收方期望收到发送方在下一个报文段的顺序号码（Seq），因此确认号码应当是上次已成功收到顺序号码（Seq）加1，32bit。</li><li>（5）Offset（TCP报文头长度)：用于存储报文头中有多少个32bit(上图的一行)，存储长度为4bit，最大可表示（2^3+2^2+2^1+1）<em>32bit=60bytes的报文头。最小取值5，5</em>32bit=20bytes。</li><li>（6）Reserved（保留）：6bit, 均为0</li><li>（7）TCP Flags（TCP标志位）每个长度均为1bit<ul><li>CWR：压缩，TCP Flags值0x80。</li><li>ECE：拥塞，0x40。</li><li>URG：紧急，0x20。当URG=1时，表示报文段中有紧急数据，应尽快传送。</li><li>ACK：确认，0x10。当ACK = 1时，代表这是一个确认的TCP包，取值0则不是确认包。</li><li>PSH：推送，0x08。当发送端PSH=1时，接收端尽快的交付给应用进程。</li><li>RST：复位，0x04。当RST=1时，表明TCP连接中出现严重差错，必须释放连接，再重新建立连接。</li><li>SYN：同步，0x02。在建立连接是用来同步序号。SYN=1， ACK=0表示一个连接请求报文段。SYN=1，ACK=1表示同意建立连接。</li><li>FIN：终止，0x01。当FIN=1时，表明此报文段的发送端的数据已经发送完毕，并要求释放传输连接。</li></ul></li><li>（8）窗口：用来控制对方发送的数据量，通知发放已确定的发送窗口上限。</li><li>（9）检验和：该字段检验的范围包括头部和数据这两部分。由发端计算和存储，并由收端进行验证。</li><li>（10）紧急指针：紧急指针在URG=1时才有效，它指出本报文段中的紧急数据的字节数。</li><li><p>（11）TCP选项：长度可变，最长可达40字节</p><h4 id="2、TCP协议中的三次握手和四次挥手"><a href="#2、TCP协议中的三次握手和四次挥手" class="headerlink" title="2、TCP协议中的三次握手和四次挥手"></a>2、TCP协议中的三次握手和四次挥手</h4><p><img src="https://upload-images.jianshu.io/upload_images/1641067-cfbdc82ef9f5c5c0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/546" alt="TCP协议中的三次握手和四次挥手"></p></li></ul><ul><li>Seq：是发送方当前报文的顺序号码。</li><li>ack：是发送方期望对方在下次返回报文中给回的Seq。</li></ul><p>建立连接需要三次握手<br>第一次握手：客户端向服务端发送连接请求包，标志位SYN（同步序号）置为1，顺序号码为X=0。</p><p>第二次握手：服务端收到客户端发过来报文，由SYN=1知道客户端要求建立联机，则为这次连接分配资源。并向客户端发送一个SYN和ACK都置为1的TCP报文，设置初始顺序号码Y=0，将确认序号(ack)设置为上一次客户端发送过来的顺序号(Seq)加1，即X+1 = 0+1=1。</p><p>第三次握手：客户端收到服务端发来的包后检查确认号码(ack)是否正确，即第一次发送的Seq加1（X+1=1）。以及标志位ACK是否为1。若正确，服务端再次发送确认包，ACK标志位为1，SYN标志位为0。确认号码(ack)=Y+1=0+1=1，发送顺序号码(Seq)为X+1=1。Server收到后确认号码值与ACK=1则连接建立成功，可以传送数据了。</p><p>断开连接需要四次挥手<br>提醒：中断连接端可以是Client端，也可以是Server端。只要将下面两角色互换即可。<br>第一次挥手：客户端给服务端发送FIN报文，用来关闭客户端到服务端的数据传送。将标志位FIN和ACK置为1，顺序号码为X=1，确认号码为Z=1。意思是说”我Client端没有数据要发给你了，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK过来。”</p><p>第二次挥手：服务端收到FIN后，发回一个ACK(标志位ACK=1),确认号码为收到的顺序号码加1，即X=X+1=2。顺序号码为收到的确认号码=Z。意思是说“你的FIN请求我收到了，但是我还没准备好，请继续你等我的消息” 这个时候客户端就进入FIN_WAIT状态，继续等待服务端的FIN报文。</p><p>第三次挥手：当服务端确定数据已发送完成，则向客户端发送FIN报文，关闭与客户端的连接。标志位FIN和ACK置为1，顺序号码为Y=1，确认号码为X=2。意思是告诉Client端“好了，我这边数据发完了，准备好关闭连接了。”</p><p>第四次挥手：客户端收到服务器发送的FIN之后，发回ACK确认(标志位ACK=1),确认号码为收到的顺序号码加1，即Y+1=2。顺序号码为收到的确认号码X=2。意思是“我Client端知道可以关闭连接了，但是我还是不相信网络，怕 Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。“（在TIME_WAIT状态中，如果TCP client端最后一次发送的ACK丢失了，它将重新发送。TIME_WAIT状态中所需要的时间是依赖于实现方法的。典型的值为30秒、1分钟和2分钟。等待之后连接正式关闭，并且所有的资源(包括端口号)都被释放。）</p><p>为什么关闭的时候却是四次挥（握）手？<br>因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TCP是一种面向连接（连接导向）的、可靠的基于字节流的传输层通信协议。TCP将用户数据打包成报文段，它发送后启动一个定时器，另一端收到的数据进行确认、对失序的数据重新排序、丢弃重复数据。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络基础知识" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="TCP" scheme="http://yoursite.com/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>前端性能衡量指标</title>
    <link href="http://yoursite.com/2018/03/21/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E8%A1%A1%E9%87%8F%E6%8C%87%E6%A0%87/"/>
    <id>http://yoursite.com/2018/03/21/前端性能衡量指标/</id>
    <published>2018-03-21T15:11:07.000Z</published>
    <updated>2018-03-21T15:18:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍前端性能衡量指标，对于一个网站如果希望抓住用户，网站的速度以及稳定性是非常重要的。</p><a id="more"></a><h2 id="性能衡量指标"><a href="#性能衡量指标" class="headerlink" title="性能衡量指标"></a>性能衡量指标</h2><p><strong>指标：</strong></p><ul><li>白屏时间</li><li>首屏时间</li><li>用户可交互时间</li><li>完全加载时间</li><li>首字节时间</li><li>DNS 解析时间</li><li>TCP 连接时间</li><li>HTTP 请求时间</li><li>HTTP 响应时间</li></ul><p><strong>维度：</strong></p><ul><li>运营商</li><li>网络</li><li>URL</li></ul><h2 id="性能监控"><a href="#性能监控" class="headerlink" title="性能监控"></a>性能监控</h2><p><strong>如何监控</strong></p><ul><li><a href="https://link.juejin.im/?target=http%3A%2F%2Ffex.baidu.com%2Fblog%2F2014%2F05%2Fbuild-performance-monitor-in-7-days%2F" target="_blank" rel="noopener">7 天打造前端性能监控系统</a></li><li><a href="https://link.juejin.im/?target=http%3A%2F%2Fweb.jobbole.com%2F84264%2F" target="_blank" rel="noopener">使用性能API快速分析web前端性能</a></li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F37585246" target="_blank" rel="noopener">你是如何搭建 Web 前端性能监控系统的</a></li></ul><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p><strong>优化点：</strong></p><ul><li>高频事件消抖、节流。使用<em>.debounce()和</em>. throttle()，控制高频事件的操作，如：scroll、onChange<ul><li>_.debounce()的多次连续的调用，最终实际上只会调用一次；</li><li>_. throttle()将频繁调用的函数限定在一个给定的调用频率内。</li></ul></li><li>JavaScritp很快，但是DOM很慢，减少修改DOM。<ul><li>DOM的渲染需要计算DOM+CSSOM，每次DOM和CSSOM的每次修改都会触发重绘；<ul><li>渲染过程：JavaScript -&gt; Style -&gt; Layoout -&gt; Paint -&gt; Composite</li></ul></li><li>避免 position: fixed;布局，Z轴图层堆叠关系会改变，引起重绘；</li><li>图层隔离：将那些会变动的元素提升至单独的图层，比如：动画、渐变；</li><li>降低图层复杂度；</li><li>避免线程阻塞；</li><li>优化CSS；</li><li>文件：引入方式、位置、文件合并、延迟加载；</li><li>硬件加速：GPU加速渲染</li></ul></li></ul><p><strong>基于各环节优化：</strong><br><img src="https://upload-images.jianshu.io/upload_images/1726248-530cd1c4fe65d9e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="优化流程"></p><ul><li>减少http请求，合理设置 HTTP缓存</li><li>使用HTTP/2</li><li>持久连接，使用 keep-alive 或者 WebSocket</li><li>使用浏览器缓存</li><li>启用压缩</li><li>CSS Sprites</li><li>LazyLoad Images</li><li>样式文件放在顶部，脚本文件放在底部</li><li>减少 cookie 传输</li><li>CDN 加速<ul><li>CDN（contentdistribute network，内容分发网络）的本质仍然是一个缓存，而且将数据缓存在离用户最近的地方，使用户以最快速度获取数据，即所谓网络访问第一跳。</li></ul></li><li>反向代理<ul><li>传统代理服务器位于浏览器一侧，代理浏览器将http请求发送到互联网上，而反向代理服务器位于网站机房一侧，代理网站web服务器接收http请求。</li><li>论坛网站，把热门词条、帖子、博客缓存在反向代理服务器上加速用户访问速度，当这些动态内容有变化时，通过内部通知机制通知反向代理缓存失效，反向代理会重新加载最新的动态内容再次缓存起来。</li><li>此外，反向代理也可以实现负载均衡的功能，而通过负载均衡构建的应用集群可以提高系统总体处理能力，进而改善网站高并发情况下的性能。</li></ul></li><li>面向未来，考虑 service worker</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍前端性能衡量指标，对于一个网站如果希望抓住用户，网站的速度以及稳定性是非常重要的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端开发" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="前端优化" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>hexo部署到github</title>
    <link href="http://yoursite.com/2018/03/21/hexo%E9%83%A8%E7%BD%B2%E5%88%B0github/"/>
    <id>http://yoursite.com/2018/03/21/hexo部署到github/</id>
    <published>2018-03-21T07:58:43.000Z</published>
    <updated>2018-03-21T08:07:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍如何成功搭建hexo本地博客并部署到github上。</p><a id="more"></a><h3 id="一、首先搭建-hexo-本地博客"><a href="#一、首先搭建-hexo-本地博客" class="headerlink" title="一、首先搭建 hexo 本地博客"></a>一、首先搭建 hexo 本地博客</h3><p>1、git和Node.js都安装成功后，安装hexo，命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install hexo -g</span><br></pre></td></tr></table></figure></p><p>2、创建 my- hexo 文件夹，命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir my-hexo</span><br></pre></td></tr></table></figure></p><p>3、my- hexo 安装成功后，在该文件夹下执行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure></p><p>4、启动本地服务，现在已经搭建起本地的 hexo 博客了，执行以下命令，然后到浏览器输入 <code>localhost:4000</code> 查看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate 或 hexo g    // 生成静态文件</span><br><span class="line">hexo server 或 hexo s        // 启动服务器。默认情况下，访问网址为： http://localhost:4000/</span><br></pre></td></tr></table></figure></p><p>5、到此，本地博客已经搭建起来了，如下图（这是添加了文章，换了主题的博客）<br><img src="https://upload-images.jianshu.io/upload_images/1726248-7e71fb085f79722c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="我的博客"></p><h3 id="二、将-hexo-本地博客部署到github上"><a href="#二、将-hexo-本地博客部署到github上" class="headerlink" title="二、将 hexo 本地博客部署到github上"></a>二、将 hexo 本地博客部署到github上</h3><p>1、创建repository<br>这里的 repository 名必须使用你的github的用户，即我的用户名为 <code>frontend</code> ，那么网址必须为 <code>frontendX.github.io</code> ，如下图（创建repository）中红色框。<br><img src="https://upload-images.jianshu.io/upload_images/1726248-f1b9512f1b4e8e15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建repository"></p><p>2、部署<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 编辑 _config.yml ，在部署时，要把下面的 zippera 都换成你的账号名。</span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repository: https://github.com/frontendX/frontendX.git</span><br><span class="line">    branch: master</span><br><span class="line"></span><br><span class="line"> // 执行下列指令即可完成部署。</span><br><span class="line"></span><br><span class="line"> hexo g</span><br><span class="line"> hexo d</span><br><span class="line"></span><br><span class="line"> 如果提示：ERROR Deployer not found: git</span><br><span class="line"> 执行以下以下命令：npm install hexo-deployer-git --save</span><br><span class="line"></span><br><span class="line"> 完成之后再执行：</span><br><span class="line">    hexo generate</span><br><span class="line">    hexo deploy</span><br></pre></td></tr></table></figure></p><p> <strong>记住：每次修改本地文件后，需要 <code>hexo g</code> 才能保存，<code>hexo d</code> 才能部署到github。每次使用命令时，都要在该项目目录下。</strong></p><p><em>注意：部署中遇到的问题</em></p><p>当 <code>repository</code> 名是 <code>froentendX</code>（修改前 - 1）的时候，<a href="https://frontendx.github.io/" target="_blank" rel="noopener">https://frontendx.github.io/</a> 页面访问不了；需要把 <code>froentendX</code> 修改成 <code>frontendX.github.io</code>（修改后 - 2）<br><img src="https://upload-images.jianshu.io/upload_images/1726248-a80dab99d98acc8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="修改前 - 1"></p><p><img src="https://upload-images.jianshu.io/upload_images/1726248-a3e865480fa01273.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="修改后 - 2"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍如何成功搭建hexo本地博客并部署到github上。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端开发" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="github" scheme="http://yoursite.com/tags/github/"/>
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>ES6：export default 和 export 区别</title>
    <link href="http://yoursite.com/2018/03/21/ES6%EF%BC%9Aexport-default-%E5%92%8C-export-%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2018/03/21/ES6：export-default-和-export-区别/</id>
    <published>2018-03-21T01:55:47.000Z</published>
    <updated>2018-03-21T12:29:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文通过主要介绍export default 和 export 的区别。</p><a id="more"></a><h2 id="export-default-和-export-区别："><a href="#export-default-和-export-区别：" class="headerlink" title="export default 和 export 区别："></a>export default 和 export 区别：</h2><p>1.export与export default均可用于导出常量、函数、文件、模块等<br>2.你可以在其它文件或模块中通过import+(常量 | 函数 | 文件 | 模块)名的方式，将其导入，以便能够对其进行使用<br>3.在一个文件或模块中，export、import可以有多个，export default仅有一个<br>4.通过export方式导出，在导入时要加{ }，export default则不需要</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1.export</span><br><span class="line">//a.js</span><br><span class="line">export const str = &quot;blablabla~&quot;;</span><br><span class="line">export function log(sth) &#123;</span><br><span class="line">  return sth;</span><br><span class="line">&#125;</span><br><span class="line">对应的导入方式：</span><br><span class="line"></span><br><span class="line">//b.js</span><br><span class="line">import &#123; str, log &#125; from &apos;a&apos;; //也可以分开写两次，导入的时候带花括号</span><br><span class="line"></span><br><span class="line">2.export default</span><br><span class="line">//a.js</span><br><span class="line">const str = &quot;blablabla~&quot;;</span><br><span class="line">export default str;</span><br><span class="line">对应的导入方式：</span><br><span class="line"></span><br><span class="line">//b.js</span><br><span class="line">import str from &apos;a&apos;; //导入的时候没有花括号</span><br></pre></td></tr></table></figure><h2 id="使用export-default命令，为模块指定默认输出，这样就不需要知道所要加载模块的变量名"><a href="#使用export-default命令，为模块指定默认输出，这样就不需要知道所要加载模块的变量名" class="headerlink" title="使用export default命令，为模块指定默认输出，这样就不需要知道所要加载模块的变量名"></a>使用export default命令，为模块指定默认输出，这样就不需要知道所要加载模块的变量名</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//a.js</span><br><span class="line">let sex = &quot;boy&quot;;</span><br><span class="line">export default sex（sex不能加大括号）</span><br><span class="line">//原本直接export sex外部是无法识别的，加上default就可以了.但是一个文件内最多只能有一个export default。</span><br><span class="line">其实此处相当于为sex变量值&quot;boy&quot;起了一个系统默认的变量名default，自然default只能有一个值，所以一个文件内不能有多个export default。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// b.js</span><br><span class="line">本质上，a.js文件的export default输出一个叫做default的变量，然后系统允许你为它取任意名字。所以可以为import的模块起任何变量名，且不需要用大括号包含</span><br><span class="line">import any from &quot;./a.js&quot;</span><br><span class="line">import any12 from &quot;./a.js&quot;</span><br><span class="line">console.log(any,any12)   // boy,boy</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文通过主要介绍export default 和 export 的区别。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端开发" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/03/19/hello-world/"/>
    <id>http://yoursite.com/2018/03/19/hello-world/</id>
    <published>2018-03-19T01:55:47.000Z</published>
    <updated>2018-03-21T12:29:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post2"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端开发" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
</feed>
